{"version":3,"file":"use-sticky-columns.js","sourceRoot":"","sources":["../../../../src/table/sticky-columns/use-sticky-columns.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nimport React, { useCallback, useEffect, useMemo, useRef } from 'react';\nimport AsyncStore, { ReadonlyAsyncStore } from '../../area-chart/async-store';\nimport clsx from 'clsx';\nimport { useResizeObserver, useStableCallback } from '@cloudscape-design/component-toolkit/internal';\nimport {\n  CellOffsets,\n  StickyColumnsCellState,\n  StickyColumnsProps,\n  StickyColumnsState,\n  StickyColumnsWrapperState,\n} from './interfaces';\nimport { isCellStatesEqual, isWrapperStatesEqual, updateCellOffsets } from './utils';\n\n// We allow the table to have a minimum of 148px of available space besides the sum of the widths of the sticky columns\n// This value is an UX recommendation and is approximately 1/3 of our smallest breakpoint (465px)\nconst MINIMUM_SCROLLABLE_SPACE = 148;\n\nexport interface StickyColumnsModel {\n  store: ReadonlyAsyncStore<StickyColumnsState>;\n  style: {\n    wrapper?: React.CSSProperties;\n  };\n  refs: {\n    table: React.RefCallback<HTMLElement>;\n    wrapper: React.RefCallback<HTMLElement>;\n    cell: (columnId: PropertyKey, node: null | HTMLElement) => void;\n  };\n}\n\nexport function useStickyColumns({\n  visibleColumns,\n  stickyColumnsFirst,\n  stickyColumnsLast,\n}: StickyColumnsProps): StickyColumnsModel {\n  const store = useMemo(() => new StickyColumnsStore(), []);\n  const wrapperRef = useRef<HTMLElement>(null) as React.MutableRefObject<null | HTMLElement>;\n  const tableRef = useRef<HTMLElement>(null) as React.MutableRefObject<null | HTMLElement>;\n  const cellsRef = useRef(new Map<PropertyKey, HTMLElement>());\n\n  const hasStickyColumns = stickyColumnsFirst + stickyColumnsLast > 0;\n\n  const updateStickyStyles = useStableCallback(() => {\n    if (wrapperRef.current && tableRef.current) {\n      store.updateCellStyles({\n        wrapper: wrapperRef.current,\n        table: tableRef.current,\n        cells: cellsRef.current,\n        visibleColumns,\n        stickyColumnsFirst,\n        stickyColumnsLast,\n      });\n    }\n  });\n\n  useResizeObserver(wrapperRef, updateStickyStyles);\n\n  useResizeObserver(tableRef, updateStickyStyles);\n\n  useEffect(() => {\n    if (wrapperRef.current && tableRef.current) {\n      store.updateCellStyles({\n        wrapper: wrapperRef.current,\n        table: tableRef.current,\n        cells: cellsRef.current,\n        visibleColumns,\n        stickyColumnsFirst,\n        stickyColumnsLast,\n      });\n    }\n  }, [store, stickyColumnsFirst, stickyColumnsLast, visibleColumns]);\n\n  // Update wrapper styles imperatively to avoid unnecessary re-renders.\n  useEffect(() => {\n    if (!hasStickyColumns) {\n      return;\n    }\n\n    const selector = (state: StickyColumnsState) => state.wrapperState;\n\n    const updateWrapperStyles = (state: StickyColumnsWrapperState, prev: StickyColumnsWrapperState) => {\n      if (isWrapperStatesEqual(state, prev)) {\n        return;\n      }\n\n      if (wrapperRef.current) {\n        wrapperRef.current.style.scrollPaddingLeft = state.scrollPaddingLeft + 'px';\n        wrapperRef.current.style.scrollPaddingRight = state.scrollPaddingRight + 'px';\n      }\n    };\n\n    const unsubscribe = store.subscribe(selector, (newState, prevState) =>\n      updateWrapperStyles(selector(newState), selector(prevState))\n    );\n    return unsubscribe;\n  }, [store, hasStickyColumns]);\n\n  const setWrapper = useCallback(\n    (node: null | HTMLElement) => {\n      if (wrapperRef.current) {\n        wrapperRef.current.removeEventListener('scroll', updateStickyStyles);\n      }\n      if (node && hasStickyColumns) {\n        node.addEventListener('scroll', updateStickyStyles);\n      }\n      wrapperRef.current = node;\n    },\n    [hasStickyColumns, updateStickyStyles]\n  );\n\n  const setTable = useCallback((node: null | HTMLElement) => {\n    tableRef.current = node;\n  }, []);\n\n  const setCell = useCallback((columnId: PropertyKey, node: null | HTMLElement) => {\n    if (node) {\n      cellsRef.current.set(columnId, node);\n    } else {\n      cellsRef.current.delete(columnId);\n    }\n  }, []);\n\n  return {\n    store,\n    style: {\n      // Provide wrapper styles as props so that a re-render won't cause invalidation.\n      wrapper: hasStickyColumns ? { ...store.get().wrapperState } : undefined,\n    },\n    refs: { wrapper: setWrapper, table: setTable, cell: setCell },\n  };\n}\n\ninterface UseStickyCellStylesProps {\n  stickyColumns: StickyColumnsModel;\n  columnId: PropertyKey;\n  getClassName: (styles: null | StickyColumnsCellState) => Record<string, boolean>;\n}\n\ninterface StickyCellStyles {\n  ref: React.RefCallback<HTMLElement>;\n  className?: string;\n  style?: React.CSSProperties;\n}\n\nexport function useStickyCellStyles({\n  stickyColumns,\n  columnId,\n  getClassName,\n}: UseStickyCellStylesProps): StickyCellStyles {\n  const setCell = stickyColumns.refs.cell;\n\n  // unsubscribeRef to hold the function to unsubscribe from the store's updates\n  const unsubscribeRef = useRef<null | (() => void)>(null);\n\n  // refCallback updates the cell ref and sets up the store subscription\n  const refCallback = useCallback(\n    (cellElement: null | HTMLElement) => {\n      if (unsubscribeRef.current) {\n        // Unsubscribe before we do any updates to avoid leaving any subscriptions hanging\n        unsubscribeRef.current();\n      }\n\n      // Update cellRef and the store's state to point to the new DOM node\n      setCell(columnId, cellElement);\n\n      // Update cell styles imperatively to avoid unnecessary re-renders.\n      const selector = (state: StickyColumnsState) => state.cellState.get(columnId) ?? null;\n\n      const updateCellStyles = (state: null | StickyColumnsCellState, prev: null | StickyColumnsCellState) => {\n        if (isCellStatesEqual(state, prev)) {\n          return;\n        }\n\n        const className = getClassName(state);\n        if (cellElement) {\n          Object.keys(className).forEach(key => {\n            if (className[key]) {\n              cellElement.classList.add(key);\n            } else {\n              cellElement.classList.remove(key);\n            }\n          });\n          cellElement.style.left = state?.offset.left !== undefined ? `${state.offset.left}px` : '';\n          cellElement.style.right = state?.offset.right !== undefined ? `${state.offset.right}px` : '';\n        }\n      };\n\n      // If the node is not null (i.e., the table cell is being mounted or updated, not unmounted),\n      // set up a new subscription to the store's updates\n      if (cellElement) {\n        unsubscribeRef.current = stickyColumns.store.subscribe(selector, (newState, prevState) => {\n          updateCellStyles(selector(newState), selector(prevState));\n        });\n      }\n    },\n\n    // getClassName is expected to be pure\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [columnId, setCell, stickyColumns.store]\n  );\n\n  // Provide cell styles as props so that a re-render won't cause invalidation.\n  const cellStyles = stickyColumns.store.get().cellState.get(columnId);\n  return {\n    ref: refCallback,\n    className: cellStyles ? clsx(getClassName(cellStyles)) : undefined,\n    style: cellStyles?.offset ?? undefined,\n  };\n}\n\ninterface UpdateCellStylesProps {\n  wrapper: HTMLElement;\n  table: HTMLElement;\n  cells: Map<PropertyKey, HTMLElement>;\n  visibleColumns: readonly PropertyKey[];\n  stickyColumnsFirst: number;\n  stickyColumnsLast: number;\n}\n\nexport default class StickyColumnsStore extends AsyncStore<StickyColumnsState> {\n  private cellOffsets: CellOffsets = {\n    offsets: new Map(),\n    stickyWidthLeft: 0,\n    stickyWidthRight: 0,\n  };\n  private isStuckToTheLeft = false;\n  private isStuckToTheRight = false;\n  private padLeft = false;\n\n  constructor() {\n    super({ cellState: new Map(), wrapperState: { scrollPaddingLeft: 0, scrollPaddingRight: 0 } });\n  }\n\n  public updateCellStyles(props: UpdateCellStylesProps) {\n    const hasStickyColumns = props.stickyColumnsFirst + props.stickyColumnsLast > 0;\n    const hadStickyColumns = this.cellOffsets.offsets.size > 0;\n\n    if (hasStickyColumns || hadStickyColumns) {\n      this.updateScroll(props);\n      this.updateCellOffsets(props);\n      this.set(() => ({\n        cellState: this.generateCellStyles(props),\n        wrapperState: {\n          scrollPaddingLeft: this.cellOffsets.stickyWidthLeft,\n          scrollPaddingRight: this.cellOffsets.stickyWidthRight,\n        },\n      }));\n    }\n  }\n\n  private updateScroll(props: UpdateCellStylesProps) {\n    const wrapperScrollLeft = props.wrapper.scrollLeft;\n    const wrapperScrollWidth = props.wrapper.scrollWidth;\n    const wrapperClientWidth = props.wrapper.clientWidth;\n    const tablePaddingLeft = parseFloat(getComputedStyle(props.table).paddingLeft) || 0;\n    const tablePaddingRight = parseFloat(getComputedStyle(props.table).paddingRight) || 0;\n\n    this.isStuckToTheLeft = wrapperScrollLeft > tablePaddingLeft;\n\n    // Math.ceil() is used here to address an edge-case in certain browsers, where they return non-integer wrapperScrollLeft values\n    // which are lower than expected (sub-pixel difference), resulting in the table always being in the \"stuck to the right\" state\n    this.isStuckToTheRight = Math.ceil(wrapperScrollLeft) < wrapperScrollWidth - wrapperClientWidth - tablePaddingRight;\n\n    this.padLeft = tablePaddingLeft !== 0 && this.isStuckToTheLeft;\n  }\n\n  private generateCellStyles = (props: UpdateCellStylesProps): Map<PropertyKey, StickyColumnsCellState> => {\n    const isEnabled = this.isEnabled(props);\n    const lastLeftStickyColumnIndex = props.stickyColumnsFirst - 1;\n    const lastRightStickyColumnIndex = props.visibleColumns.length - props.stickyColumnsLast;\n\n    return props.visibleColumns.reduce((acc, columnId, index) => {\n      let stickySide = 'non-sticky';\n      if (index < props.stickyColumnsFirst) {\n        stickySide = 'left';\n      } else if (index >= props.visibleColumns.length - props.stickyColumnsLast) {\n        stickySide = 'right';\n      }\n\n      if (!isEnabled || stickySide === 'non-sticky') {\n        return acc;\n      }\n\n      // Determine the offset of the sticky column using the `cellOffsets` state object\n      const isFirstColumn = index === 0;\n      const stickyColumnOffsetLeft = this.cellOffsets.offsets.get(columnId)?.first ?? 0;\n      const stickyColumnOffsetRight = this.cellOffsets.offsets.get(columnId)?.last ?? 0;\n\n      acc.set(columnId, {\n        padLeft: isFirstColumn && this.padLeft,\n        lastLeft: this.isStuckToTheLeft && lastLeftStickyColumnIndex === index,\n        lastRight: this.isStuckToTheRight && lastRightStickyColumnIndex === index,\n        offset: {\n          left: stickySide === 'left' ? stickyColumnOffsetLeft : undefined,\n          right: stickySide === 'right' ? stickyColumnOffsetRight : undefined,\n        },\n      });\n      return acc;\n    }, new Map<PropertyKey, StickyColumnsCellState>());\n  };\n\n  private updateCellOffsets = (props: UpdateCellStylesProps): void => {\n    this.cellOffsets = updateCellOffsets(props.cells, props);\n  };\n\n  private isEnabled = (props: UpdateCellStylesProps): boolean => {\n    const noStickyColumns = props.stickyColumnsFirst + props.stickyColumnsLast === 0;\n    if (noStickyColumns) {\n      return false;\n    }\n\n    const wrapperWidth = props.wrapper.getBoundingClientRect().width;\n    const tableWidth = props.table.getBoundingClientRect().width;\n    const isWrapperScrollable = tableWidth > wrapperWidth;\n    if (!isWrapperScrollable) {\n      return false;\n    }\n\n    const totalStickySpace = this.cellOffsets.stickyWidthLeft + this.cellOffsets.stickyWidthRight;\n    const tablePaddingLeft = parseFloat(getComputedStyle(props.table).paddingLeft) || 0;\n    const tablePaddingRight = parseFloat(getComputedStyle(props.table).paddingRight) || 0;\n    const hasEnoughScrollableSpace =\n      totalStickySpace + MINIMUM_SCROLLABLE_SPACE + tablePaddingLeft + tablePaddingRight < wrapperWidth;\n    if (!hasEnoughScrollableSpace) {\n      return false;\n    }\n\n    return true;\n  };\n}\n"]}