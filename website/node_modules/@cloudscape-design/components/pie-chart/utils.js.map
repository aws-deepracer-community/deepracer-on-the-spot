{"version":3,"file":"utils.js","sourceRoot":"","sources":["../../../src/pie-chart/utils.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { ComponentFormatFunction } from '../i18n/context';\nimport { PieChartProps } from './interfaces';\nimport styles from './styles.css.js';\n\nexport interface Dimension {\n  innerRadius: number;\n  outerRadius: number;\n  padding: number;\n  paddingLabels: number;\n  innerLabelPadding: number;\n  cornerRadius?: number;\n}\n\nconst minRadius = 30;\nconst paddingLabels = 44; // = 2 * (size-lineHeight-body-100)\nconst defaultPadding = 12; // = space-s\nconst smallPadding = 8; // = space-xs\nexport const minLabelLineAngularPadding = Math.PI / 20;\n\nexport const dimensionsBySize: Record<NonNullable<PieChartProps['size']>, Dimension> = {\n  small: {\n    innerRadius: 33,\n    outerRadius: 50,\n    innerLabelPadding: smallPadding,\n    padding: smallPadding,\n    paddingLabels,\n  },\n  medium: {\n    innerRadius: 66,\n    outerRadius: 100,\n    innerLabelPadding: defaultPadding,\n    padding: defaultPadding,\n    paddingLabels,\n  },\n  large: {\n    innerRadius: 93,\n    outerRadius: 140,\n    innerLabelPadding: defaultPadding,\n    padding: defaultPadding,\n    paddingLabels,\n  },\n};\n\nexport const refreshDimensionsBySize: Record<NonNullable<PieChartProps['size']>, Dimension> = {\n  small: {\n    ...dimensionsBySize.small,\n    innerRadius: 38,\n    cornerRadius: 3,\n  },\n  medium: {\n    ...dimensionsBySize.medium,\n    innerRadius: 75,\n    cornerRadius: 4,\n  },\n  large: {\n    ...dimensionsBySize.large,\n    innerRadius: 105,\n    cornerRadius: 5,\n  },\n};\n\n/**\n * When `size` is a string (\"small\", \"medium\" or \"large\") the predefined pie chart element dimensions for classic and visual refresh are used.\n * When `size` is a number the outer and inner radii are computed and the rest of the dimensions are taken from the closest predefined size.\n */\nexport function getDimensionsBySize({\n  size,\n  hasLabels,\n  visualRefresh,\n}: {\n  size: NonNullable<PieChartProps['size']> | number;\n  hasLabels: boolean;\n  visualRefresh?: boolean;\n}): Dimension & { size: NonNullable<PieChartProps['size']> } {\n  if (typeof size === 'string') {\n    const dimensions = visualRefresh ? refreshDimensionsBySize[size] : dimensionsBySize[size];\n    return { ...dimensions, size };\n  }\n  const sizeSpec = visualRefresh ? refreshDimensionsBySize : dimensionsBySize;\n  const getPixelSize = (d: Dimension) => d.outerRadius * 2 + d.padding * 2 + (hasLabels ? d.paddingLabels : 0) * 2;\n\n  let matchedSize: NonNullable<PieChartProps['size']> = 'small';\n  if (size > getPixelSize(sizeSpec.medium)) {\n    matchedSize = 'medium';\n  }\n  if (size > getPixelSize(sizeSpec.large)) {\n    matchedSize = 'large';\n  }\n\n  const padding = sizeSpec[matchedSize].padding;\n  const paddingLabels = hasLabels ? sizeSpec[matchedSize].paddingLabels : 0;\n  const radiiRatio = sizeSpec[matchedSize].outerRadius / sizeSpec[matchedSize].innerRadius;\n  const outerRadius = Math.max(minRadius, (size - 2 * paddingLabels - 2 * padding) / 2);\n  const innerRadius = outerRadius / radiiRatio;\n\n  return { ...sizeSpec[matchedSize], outerRadius, innerRadius, size: matchedSize };\n}\n\nexport const defaultDetails =\n  (i18n: ComponentFormatFunction<'pie-chart'>, i18nStrings: PieChartProps.I18nStrings) =>\n  (datum: PieChartProps.Datum, dataSum: number) =>\n    [\n      { key: i18n('i18nStrings.detailsValue', i18nStrings.detailsValue) || '', value: datum.value },\n      {\n        key: i18n('i18nStrings.detailsPercentage', i18nStrings.detailsPercentage) || '',\n        value: `${((datum.value * 100) / dataSum).toFixed(0)}%`,\n      },\n    ];\n\n/**\n * Adjusts the position of the given label nodes to avoid visual overlapping.\n * @param nodes List of label nodes of the entire chart (both left and right side)\n * @param markers Markers array that was calculated in <Labels>, but we just need the `endY` values\n * @param leftSide Boolean flag whether we are processing the left or right side of the chart labels\n */\nexport const balanceLabelNodes = (\n  nodes: NodeListOf<SVGGElement>,\n  markers: Array<{ endY: number; endX: number }>,\n  leftSide: boolean,\n  radius: number\n) => {\n  const MARGIN = 10;\n\n  let previousBBox: { x: number; y: number; height: number } | null = null;\n\n  // When traversing the right side of labels, we start at the beginning of the array and go forwards.\n  // For the left side, we need to traverse backwards from the end, so that overlapping nodes are pushed down in the right order.\n  let i = leftSide ? nodes.length - 1 : 0;\n\n  while ((leftSide && i >= 0) || (!leftSide && i < nodes.length)) {\n    const node = nodes[i];\n\n    // Currently using dataset attributes to determine the base position.\n    // This implementation can be changed back to using `getBBox` when we drop IE11 support.\n    // Unfortunately, there is no good alternative for `getBBox` that is supported by IE11.\n    // `getBoundingClientRect` works for width and height calculations in SVG, but the x/y positions are inaccurate.\n    const x = parseFloat(node.getAttribute('data-x') || '0');\n    const y = parseFloat(node.getAttribute('data-y') || '0');\n    const box = {\n      x,\n      y,\n      height: node.getBoundingClientRect().height,\n    };\n\n    const marker = markers[i];\n\n    if (leftSide) {\n      i--;\n    } else {\n      i++;\n    }\n\n    if (!previousBBox) {\n      previousBBox = box;\n      node.setAttribute('transform', '');\n      continue;\n    }\n\n    if ((!leftSide && box.x < 0) || (leftSide && box.x >= 0)) {\n      // We have reached a label that is on the other side of the chart, so we're done.\n      break;\n    }\n\n    node.setAttribute('transform', '');\n\n    // Calculate how much the current node is overlapping with the previous one.\n    const yOffset = previousBBox.y + previousBBox.height + MARGIN - box.y;\n\n    if (yOffset > 0) {\n      const xOffset = computeXOffset(box, yOffset, radius) * (leftSide ? -1 : 1);\n      // Move the label down.\n      node.setAttribute('transform', `translate(${xOffset} ${yOffset})`);\n\n      // Adjust the attached line accordingly.\n      const lineNode = node.parentNode?.querySelector(`.${styles['label-line']}`);\n      if (lineNode) {\n        const { endY, endX } = marker;\n        lineNode.setAttribute('y2', '' + (endY + yOffset));\n        lineNode.setAttribute('x2', '' + (endX + xOffset));\n      }\n\n      // Update the position accordingly to inform the next label\n      box.y += yOffset;\n      box.x += xOffset;\n    }\n\n    previousBBox = box;\n  }\n};\n\nconst squareDistance = (edge: [number, number]): number => Math.pow(edge[0], 2) + Math.pow(edge[1], 2);\n\nconst computeXOffset = (box: { x: number; y: number; height: number }, yOffset: number, radius: number): number => {\n  const upperEdge: [number, number] = [box.x, box.y + yOffset];\n  const lowerEdge: [number, number] = [box.x, box.y + box.height + yOffset];\n  const closestEdge = squareDistance(upperEdge) < squareDistance(lowerEdge) ? upperEdge : lowerEdge;\n\n  if (squareDistance(closestEdge) < Math.pow(radius, 2)) {\n    return Math.sqrt(Math.pow(radius, 2) - Math.pow(closestEdge[1], 2)) - Math.abs(closestEdge[0]);\n  }\n  return 0;\n};\n\nexport const computeSmartAngle = (startAngle: number, endAngle: number, optimize = false): number => {\n  if (!optimize || endAngle - startAngle < 2 * minLabelLineAngularPadding) {\n    return (endAngle + startAngle) / 2;\n  }\n  const paddedStartAngle = startAngle + minLabelLineAngularPadding;\n  const paddedEndAngle = endAngle - minLabelLineAngularPadding;\n  if (paddedStartAngle < 0 && paddedEndAngle > 0) {\n    return 0;\n  }\n  if (paddedStartAngle < Math.PI && paddedEndAngle > Math.PI) {\n    return Math.PI;\n  }\n\n  const endAngleMinDistance = Math.min(\n    paddedEndAngle,\n    Math.abs(Math.PI - paddedEndAngle),\n    2 * Math.PI - paddedEndAngle\n  );\n  const startAngleMinDistance = Math.min(\n    paddedStartAngle,\n    Math.abs(Math.PI - paddedStartAngle),\n    2 * Math.PI - paddedStartAngle\n  );\n  if (endAngleMinDistance < startAngleMinDistance) {\n    return paddedEndAngle;\n  }\n  return paddedStartAngle;\n};\n"]}