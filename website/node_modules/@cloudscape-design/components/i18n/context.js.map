{"version":3,"file":"context.js","sourceRoot":"","sources":["../../../src/i18n/context.ts"],"names":[],"mappings":"AAAA,qEAAqE;AACrE,sCAAsC;AAEtC,OAAO,KAAK,EAAE,EAAE,UAAU,EAAE,MAAM,OAAO,CAAC;AAgB1C,MAAM,CAAC,MAAM,mBAAmB,GAAG,KAAK,CAAC,aAAa,CAA2B;IAC/E,MAAM,EAAE,IAAI;IACZ,MAAM,EAAE,CAAI,UAAkB,EAAE,UAAkB,EAAE,IAAY,EAAE,QAAW,EAAE,EAAE,CAAC,QAAQ;CAC3F,CAAC,CAAC;AAEH,MAAM,UAAU,SAAS;IACvB,OAAO,UAAU,CAAC,mBAAmB,CAAC,CAAC,MAAM,CAAC;AAChD,CAAC;AA4BD,MAAM,UAAU,eAAe,CAC7B,aAA4B;IAE5B,MAAM,EAAE,MAAM,EAAE,GAAG,UAAU,CAAC,mBAAmB,CAAC,CAAC;IACnD,OAAO,CACL,GAAe,EACf,QAAmB,EACnB,aAAuF,EACvF,EAAE;QACF,OAAO,MAAM,CAAC,+BAA+B,EAAE,aAAa,EAAE,GAAG,EAAE,QAAQ,EAAE,aAAa,CAAC,CAAC;IAC9F,CAAC,CAAC;AACJ,CAAC","sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nimport React, { useContext } from 'react';\nimport { I18nFormatArgTypes } from './messages-types';\n\nexport type CustomHandler<ReturnValue, FormatFnArgs> = (formatFn: (args: FormatFnArgs) => string) => ReturnValue;\n\nexport interface FormatFunction {\n  (namespace: string, component: string, key: string, provided: string): string;\n  (namespace: string, component: string, key: string, provided: string | undefined): string | undefined;\n  <T, A = unknown>(namespace: string, component: string, key: string, provided: T, handler?: CustomHandler<T, A>): T;\n}\n\nexport interface InternalI18nContextProps {\n  locale: string | null;\n  format: FormatFunction;\n}\n\nexport const InternalI18nContext = React.createContext<InternalI18nContextProps>({\n  locale: null,\n  format: <T>(_namespace: string, _component: string, _key: string, provided: T) => provided,\n});\n\nexport function useLocale(): string | null {\n  return useContext(InternalI18nContext).locale;\n}\n\n/**\n * Utility to get \"keyof T\" but exclude number or symbol types.\n * TypeScript allows those types because JS implicitly casts them to string.\n */\ntype StringKeyOf<T> = Extract<keyof T, string>;\n\nexport interface ComponentFormatFunction<ComponentName extends StringKeyOf<I18nFormatArgTypes>> {\n  <MessageKey extends StringKeyOf<I18nFormatArgTypes[ComponentName]>>(\n    key: MessageKey,\n    provided: string,\n    handler?: CustomHandler<string, I18nFormatArgTypes[ComponentName][MessageKey]>\n  ): string;\n  <MessageKey extends StringKeyOf<I18nFormatArgTypes[ComponentName]>>(\n    key: MessageKey,\n    provided: string | undefined,\n    handler?: CustomHandler<string, I18nFormatArgTypes[ComponentName][MessageKey]>\n  ): string | undefined;\n  <MessageKey extends StringKeyOf<I18nFormatArgTypes[ComponentName]>, ReturnValue>(\n    key: MessageKey,\n    provided: ReturnValue,\n    handler: I18nFormatArgTypes[ComponentName][MessageKey] extends never\n      ? never\n      : CustomHandler<ReturnValue, I18nFormatArgTypes[ComponentName][MessageKey]>\n  ): ReturnValue;\n}\n\nexport function useInternalI18n<ComponentName extends StringKeyOf<I18nFormatArgTypes>>(\n  componentName: ComponentName\n): ComponentFormatFunction<ComponentName> {\n  const { format } = useContext(InternalI18nContext);\n  return <MessageKey extends StringKeyOf<I18nFormatArgTypes[ComponentName]>, ValueType>(\n    key: MessageKey,\n    provided: ValueType,\n    customHandler?: CustomHandler<ValueType, I18nFormatArgTypes[ComponentName][MessageKey]>\n  ) => {\n    return format('@cloudscape-design/components', componentName, key, provided, customHandler);\n  };\n}\n"]}