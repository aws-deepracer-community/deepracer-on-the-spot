{"version":3,"file":"scroll-utils.js","sourceRoot":"","sources":["../../../src/tabs/scroll-utils.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport smoothScroll from './smooth-scroll';\nimport { isRtl, getScrollInlineStart } from '../internal/direction';\n\nexport const onPaginationClick = (\n  headerBarRef: React.RefObject<HTMLUListElement>,\n  direction: 'forward' | 'backward'\n): void => {\n  if (!headerBarRef?.current) {\n    return;\n  }\n  const element = headerBarRef.current;\n  const { scrollLeft, scrollWidth, offsetWidth } = element;\n\n  // Scroll each paginated section by 75% of what is already visible\n  const paginatedSectionSize = Math.ceil(element.clientWidth * 0.75);\n\n  const scrollDistance =\n    direction === 'forward'\n      ? Math.min(Math.abs(scrollLeft) + paginatedSectionSize, scrollWidth - offsetWidth)\n      : Math.max(Math.abs(scrollLeft) - paginatedSectionSize, 0);\n\n  // scroll destination needs to be a negative number if the direction is RTL\n  const scrollTo = isRtl(element) ? scrollDistance * -1 : scrollDistance;\n\n  smoothScroll(element, scrollTo);\n};\n\nexport const hasHorizontalOverflow = (\n  headerBar: HTMLElement,\n  inlineStartOverflowButton: React.RefObject<HTMLElement>\n): boolean => {\n  const { offsetWidth, scrollWidth } = headerBar;\n\n  // Need to account for pagination button width when deciding if there would be overflow without them\n  const paginationButtonsWidth = inlineStartOverflowButton.current && 2 * inlineStartOverflowButton.current.offsetWidth;\n  return paginationButtonsWidth ? scrollWidth > offsetWidth + paginationButtonsWidth : scrollWidth > offsetWidth;\n};\n\nexport const hasInlineStartOverflow = (headerBar: HTMLElement): boolean => {\n  return getScrollInlineStart(headerBar) > 0;\n};\n\nexport const hasInlineEndOverflow = (headerBar: HTMLElement): boolean => {\n  return Math.ceil(getScrollInlineStart(headerBar)) < headerBar.scrollWidth - headerBar.offsetWidth;\n};\n\nexport const scrollIntoView = (tabHeader: HTMLElement, headerBar: HTMLElement, smooth = true): void => {\n  if (!tabHeader || !headerBar) {\n    return;\n  }\n  // Extra left and right margin to always make the focus ring visible\n  const margin = 2;\n  let updatedLeftScroll = headerBar.scrollLeft;\n\n  // Anchor tab to left of scroll parent\n  updatedLeftScroll = Math.min(updatedLeftScroll, tabHeader.offsetLeft - margin);\n  // Anchor tab to right of scroll parent\n  updatedLeftScroll = Math.max(\n    updatedLeftScroll,\n    tabHeader.offsetLeft + tabHeader.offsetWidth - headerBar.offsetWidth + margin\n  );\n  if (smooth) {\n    smoothScroll(headerBar, updatedLeftScroll);\n  } else {\n    headerBar.scrollLeft = updatedLeftScroll;\n  }\n};\n"]}