{"version":3,"file":"positions.js","sourceRoot":"","sources":["../../../../src/popover/utils/positions.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { PopoverProps, InternalPosition, BoundingBox, Dimensions } from '../interfaces';\n\n// A structure describing how the popover should be positioned\ninterface CalculatedPosition {\n  scrollable?: boolean;\n  internalPosition: InternalPosition;\n  rect: BoundingBox;\n}\n\ninterface ElementGroup {\n  body: Dimensions;\n  trigger: BoundingBox;\n  arrow: Dimensions;\n}\n\nconst ARROW_OFFSET = 12;\n\nexport const PRIORITY_MAPPING: Record<PopoverProps.Position, InternalPosition[]> = {\n  top: [\n    'top-center',\n    'top-right',\n    'top-left',\n    'bottom-center',\n    'bottom-right',\n    'bottom-left',\n    'right-top',\n    'right-bottom',\n    'left-top',\n    'left-bottom',\n  ],\n  bottom: [\n    'bottom-center',\n    'bottom-right',\n    'bottom-left',\n    'top-center',\n    'top-right',\n    'top-left',\n    'right-top',\n    'right-bottom',\n    'left-top',\n    'left-bottom',\n  ],\n  left: [\n    'left-top',\n    'left-bottom',\n    'right-top',\n    'right-bottom',\n    'bottom-center',\n    'top-center',\n    'bottom-left',\n    'top-left',\n    'bottom-right',\n    'top-right',\n  ],\n  right: [\n    'right-top',\n    'right-bottom',\n    'left-top',\n    'left-bottom',\n    'bottom-center',\n    'top-center',\n    'bottom-right',\n    'top-right',\n    'bottom-left',\n    'top-left',\n  ],\n};\n\nconst RECTANGLE_CALCULATIONS: Record<InternalPosition, (r: ElementGroup) => BoundingBox> = {\n  'top-center': ({ body, trigger, arrow }) => {\n    return {\n      insetBlockStart: trigger.insetBlockStart - body.blockSize - arrow.blockSize,\n      insetInlineStart: trigger.insetInlineStart + trigger.inlineSize / 2 - body.inlineSize / 2,\n      inlineSize: body.inlineSize,\n      blockSize: body.blockSize,\n    };\n  },\n  'top-right': ({ body, trigger, arrow }) => {\n    return {\n      insetBlockStart: trigger.insetBlockStart - body.blockSize - arrow.blockSize,\n      insetInlineStart: trigger.insetInlineStart + trigger.inlineSize / 2 - ARROW_OFFSET - arrow.inlineSize / 2,\n      inlineSize: body.inlineSize,\n      blockSize: body.blockSize,\n    };\n  },\n  'top-left': ({ body, trigger, arrow }) => {\n    return {\n      insetBlockStart: trigger.insetBlockStart - body.blockSize - arrow.blockSize,\n      insetInlineStart:\n        trigger.insetInlineStart + trigger.inlineSize / 2 + ARROW_OFFSET + arrow.inlineSize / 2 - body.inlineSize,\n      inlineSize: body.inlineSize,\n      blockSize: body.blockSize,\n    };\n  },\n  'bottom-center': ({ body, trigger, arrow }) => {\n    return {\n      insetBlockStart: trigger.insetBlockStart + trigger.blockSize + arrow.blockSize,\n      insetInlineStart: trigger.insetInlineStart + trigger.inlineSize / 2 - body.inlineSize / 2,\n      inlineSize: body.inlineSize,\n      blockSize: body.blockSize,\n    };\n  },\n  'bottom-right': ({ body, trigger, arrow }) => {\n    return {\n      insetBlockStart: trigger.insetBlockStart + trigger.blockSize + arrow.blockSize,\n      insetInlineStart: trigger.insetInlineStart + trigger.inlineSize / 2 - ARROW_OFFSET - arrow.inlineSize / 2,\n      inlineSize: body.inlineSize,\n      blockSize: body.blockSize,\n    };\n  },\n  'bottom-left': ({ body, trigger, arrow }) => {\n    return {\n      insetBlockStart: trigger.insetBlockStart + trigger.blockSize + arrow.blockSize,\n      insetInlineStart:\n        trigger.insetInlineStart + trigger.inlineSize / 2 + ARROW_OFFSET + arrow.inlineSize / 2 - body.inlineSize,\n      inlineSize: body.inlineSize,\n      blockSize: body.blockSize,\n    };\n  },\n  'right-top': ({ body, trigger, arrow }) => {\n    return {\n      insetBlockStart: trigger.insetBlockStart + trigger.blockSize / 2 - ARROW_OFFSET - arrow.blockSize,\n      insetInlineStart: trigger.insetInlineStart + trigger.inlineSize + arrow.blockSize,\n      inlineSize: body.inlineSize,\n      blockSize: body.blockSize,\n    };\n  },\n  'right-bottom': ({ body, trigger, arrow }) => {\n    return {\n      insetBlockStart:\n        trigger.insetBlockStart + trigger.blockSize / 2 - body.blockSize + ARROW_OFFSET + arrow.blockSize,\n      insetInlineStart: trigger.insetInlineStart + trigger.inlineSize + arrow.blockSize,\n      inlineSize: body.inlineSize,\n      blockSize: body.blockSize,\n    };\n  },\n  'left-top': ({ body, trigger, arrow }) => {\n    return {\n      insetBlockStart: trigger.insetBlockStart + trigger.blockSize / 2 - ARROW_OFFSET - arrow.blockSize,\n      insetInlineStart: trigger.insetInlineStart - body.inlineSize - arrow.blockSize,\n      inlineSize: body.inlineSize,\n      blockSize: body.blockSize,\n    };\n  },\n  'left-bottom': ({ body, trigger, arrow }) => {\n    return {\n      insetBlockStart:\n        trigger.insetBlockStart + trigger.blockSize / 2 - body.blockSize + ARROW_OFFSET + arrow.blockSize,\n      insetInlineStart: trigger.insetInlineStart - body.inlineSize - arrow.blockSize,\n      inlineSize: body.inlineSize,\n      blockSize: body.blockSize,\n    };\n  },\n};\n\nfunction fitIntoContainer(inner: BoundingBox, outer: BoundingBox): BoundingBox {\n  let { insetInlineStart, inlineSize, insetBlockStart, blockSize } = inner;\n\n  // Adjust left boundary.\n  if (insetInlineStart < outer.insetInlineStart) {\n    inlineSize = insetInlineStart + inlineSize - outer.insetInlineStart;\n    insetInlineStart = outer.insetInlineStart;\n  }\n  // Adjust right boundary.\n  else if (insetInlineStart + inlineSize > outer.insetInlineStart + outer.inlineSize) {\n    inlineSize = outer.insetInlineStart + outer.inlineSize - insetInlineStart;\n  }\n  // Adjust top boundary.\n  if (insetBlockStart < outer.insetBlockStart) {\n    blockSize = insetBlockStart + blockSize - outer.insetBlockStart;\n    insetBlockStart = outer.insetBlockStart;\n  }\n  // Adjust bottom boundary.\n  else if (insetBlockStart + blockSize > outer.insetBlockStart + outer.blockSize) {\n    blockSize = outer.insetBlockStart + outer.blockSize - insetBlockStart;\n  }\n\n  return { insetInlineStart, inlineSize, insetBlockStart, blockSize };\n}\n\nfunction getTallestRect(rect1: BoundingBox, rect2: BoundingBox): BoundingBox {\n  return rect1.blockSize >= rect2.blockSize ? rect1 : rect2;\n}\n\nfunction getIntersection(rectangles: BoundingBox[]): BoundingBox | null {\n  let boundingBox: BoundingBox | null = null;\n  for (const currentRect of rectangles) {\n    if (!boundingBox) {\n      boundingBox = currentRect;\n      continue;\n    }\n    const insetInlineStart = Math.max(boundingBox.insetInlineStart, currentRect.insetInlineStart);\n    const insetBlockStart = Math.max(boundingBox.insetBlockStart, currentRect.insetBlockStart);\n    const insetInlineEnd = Math.min(\n      boundingBox.insetInlineStart + boundingBox.inlineSize,\n      currentRect.insetInlineStart + currentRect.inlineSize\n    );\n    const insetBlockEnd = Math.min(\n      boundingBox.insetBlockStart + boundingBox.blockSize,\n      currentRect.insetBlockStart + currentRect.blockSize\n    );\n\n    if (insetInlineEnd < insetInlineStart || insetBlockEnd < insetBlockStart) {\n      return null;\n    }\n    boundingBox = {\n      insetInlineStart,\n      insetBlockStart,\n      inlineSize: insetInlineEnd - insetInlineStart,\n      blockSize: insetBlockEnd - insetBlockStart,\n    };\n  }\n  return boundingBox;\n}\n\n/**\n * Returns the area of the intersection of passed in rectangles or a null, if there is no intersection\n */\nexport function intersectRectangles(rectangles: BoundingBox[]): number | null {\n  const boundingBox: BoundingBox | null = getIntersection(rectangles);\n  return boundingBox && boundingBox.blockSize * boundingBox.inlineSize;\n}\n\ntype CandidatePosition = CalculatedPosition & { visibleArea: BoundingBox | null };\n\n/**\n * A functions that returns the correct popover position based on screen dimensions.\n */\nexport function calculatePosition({\n  preferredPosition,\n  fixedInternalPosition,\n  trigger,\n  arrow,\n  body,\n  container,\n  viewport,\n  // the popover is only bound by the viewport if it is rendered in a portal\n  renderWithPortal,\n  allowVerticalOverflow,\n}: {\n  preferredPosition: PopoverProps.Position;\n  fixedInternalPosition?: InternalPosition;\n  trigger: BoundingBox;\n  arrow: Dimensions;\n  body: Dimensions;\n  container: BoundingBox;\n  viewport: BoundingBox;\n  // the popover is only bound by the viewport if it is rendered in a portal\n  renderWithPortal?: boolean;\n  allowVerticalOverflow?: boolean;\n}): CalculatedPosition {\n  let bestOption: CandidatePosition | null = null;\n\n  // If a fixed internal position is passed, only consider this one.\n  const preferredInternalPositions = fixedInternalPosition\n    ? [fixedInternalPosition]\n    : PRIORITY_MAPPING[preferredPosition];\n\n  // Attempt to position the popover based on the priority list for this position.\n  for (const internalPosition of preferredInternalPositions) {\n    const rect = RECTANGLE_CALCULATIONS[internalPosition]({ body, trigger, arrow });\n    const visibleArea = renderWithPortal\n      ? getIntersection([rect, viewport])\n      : getIntersection([rect, viewport, container]);\n\n    const fitsWithoutOverflow =\n      visibleArea && visibleArea.inlineSize === body.inlineSize && visibleArea.blockSize === body.blockSize;\n\n    if (fitsWithoutOverflow) {\n      return { internalPosition, rect };\n    }\n\n    const newOption = { rect, internalPosition, visibleArea };\n    bestOption = getBestOption(newOption, bestOption);\n  }\n\n  // Use best possible placement.\n  const internalPosition = bestOption?.internalPosition || 'right-top';\n  // Get default rect for that placement.\n  const rect = RECTANGLE_CALCULATIONS[internalPosition]({ body, trigger, arrow });\n\n  // Get largest possible rect that fits into the viewport or container.\n\n  // We allow the popover to overflow the viewport if allowVerticalOverflow is true _and_ the popover will be anchored to the top or the bottom.\n  // If it is anchored to the right or left, we consider that it should have enough vertical space so that applying scroll to it is a better option.\n  const tallestBoundingContainer = getTallestRect(viewport, container);\n  const boundingContainer =\n    allowVerticalOverflow && isTopOrBottom(internalPosition)\n      ? {\n          insetBlockStart: tallestBoundingContainer.insetBlockStart,\n          blockSize: tallestBoundingContainer.blockSize,\n          insetInlineStart: viewport.insetInlineStart,\n          inlineSize: viewport.inlineSize,\n        }\n      : viewport;\n\n  const optimizedRect = fitIntoContainer(rect, boundingContainer);\n\n  // If largest possible rect is shorter than original - set body scroll.\n  const scrollable = optimizedRect.blockSize < rect.blockSize;\n\n  return { internalPosition, rect: optimizedRect, scrollable };\n}\n\nfunction getBestOption(option1: CandidatePosition, option2: CandidatePosition | null) {\n  // Within calculatePosition, the only case where option2 will not be defined will be in the first call.\n  // The only case where the visibleArea of an option will be null is when the popover is totally outside of the viewport.\n  if (!option2?.visibleArea) {\n    return option1;\n  }\n  if (!option1.visibleArea) {\n    return option2;\n  }\n  // Only if none of the two options overflows horizontally, choose the best based on the visible height.\n  if (option1.visibleArea.inlineSize === option2.visibleArea.inlineSize) {\n    return option1.visibleArea.blockSize > option2.visibleArea.blockSize ? option1 : option2;\n  }\n  // Otherwise, choose the option that is less cut off horizontally.\n  return option1.visibleArea.inlineSize > option2.visibleArea.inlineSize ? option1 : option2;\n}\n\nexport function getOffsetDimensions(element: HTMLElement) {\n  return { offsetHeight: element.offsetHeight, offsetWidth: element.offsetWidth };\n}\n\nexport function getDimensions(element: HTMLElement) {\n  const computedStyle = getComputedStyle(element);\n  return {\n    inlineSize: parseFloat(computedStyle.inlineSize),\n    blockSize: parseFloat(computedStyle.blockSize),\n  };\n}\n\nfunction isTopOrBottom(internalPosition: InternalPosition) {\n  return ['top', 'bottom'].includes(internalPosition.split('-')[0]);\n}\n"]}