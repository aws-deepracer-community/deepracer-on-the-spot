{"version":3,"file":"use-popover-position.js","sourceRoot":"","sources":["../../../src/popover/use-popover-position.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nimport React, { useCallback, useRef, useState } from 'react';\nimport { BoundingBox, InternalPosition, Offset, PopoverProps } from './interfaces';\nimport { calculatePosition, getDimensions, getOffsetDimensions } from './utils/positions';\nimport { nodeContains } from '@cloudscape-design/component-toolkit/dom';\nimport {\n  calculateScroll,\n  getFirstScrollableParent,\n  scrollRectangleIntoView,\n} from '../internal/utils/scrollable-containers';\nimport { getContainingBlock } from '../internal/utils/dom';\nimport { getLogicalBoundingClientRect } from '../internal/direction';\n\nexport default function usePopoverPosition({\n  popoverRef,\n  bodyRef,\n  arrowRef,\n  trackRef,\n  contentRef,\n  allowScrollToFit,\n  allowVerticalOverflow,\n  preferredPosition,\n  renderWithPortal,\n  keepPosition,\n}: {\n  popoverRef: React.RefObject<HTMLDivElement | null>;\n  bodyRef: React.RefObject<HTMLDivElement | null>;\n  arrowRef: React.RefObject<HTMLDivElement | null>;\n  trackRef: React.RefObject<HTMLElement | SVGElement | null>;\n  contentRef: React.RefObject<HTMLDivElement | null>;\n  allowScrollToFit?: boolean;\n  allowVerticalOverflow?: boolean;\n  preferredPosition: PopoverProps.Position;\n  renderWithPortal?: boolean;\n  keepPosition?: boolean;\n}) {\n  const previousInternalPositionRef = useRef<InternalPosition | null>(null);\n  const [popoverStyle, setPopoverStyle] = useState<Partial<Offset>>({});\n  const [internalPosition, setInternalPosition] = useState<InternalPosition | null>(null);\n\n  // Store the handler in a ref so that it can still be replaced from outside of the listener closure.\n  const positionHandlerRef = useRef<() => void>(() => {});\n\n  const updatePositionHandler = useCallback(\n    (onContentResize = false) => {\n      if (!trackRef.current || !popoverRef.current || !bodyRef.current || !contentRef.current || !arrowRef.current) {\n        return;\n      }\n\n      // Get important elements\n      const popover = popoverRef.current;\n      const body = bodyRef.current;\n      const arrow = arrowRef.current;\n      const document = popover.ownerDocument;\n      const track = trackRef.current;\n\n      // If the popover body isn't being rendered for whatever reason (e.g. \"display: none\" or JSDOM),\n      // or track does not belong to the document - bail on calculating dimensions.\n      const { offsetWidth, offsetHeight } = getOffsetDimensions(popover);\n      if (offsetWidth === 0 || offsetHeight === 0 || !nodeContains(document.body, track)) {\n        return;\n      }\n\n      // Imperatively move body off-screen to give it room to expand.\n      // Not doing this in React because this recalculation should happen\n      // in the span of a single frame without rerendering anything.\n      const prevInsetBlockStart = popover.style.insetBlockStart;\n      const prevInsetInlineStart = popover.style.insetInlineStart;\n\n      popover.style.insetBlockStart = '0';\n      popover.style.insetInlineStart = '0';\n      // Imperatively remove body styles that can remain from the previous computation.\n      body.style.maxBlockSize = '';\n      body.style.overflowX = '';\n      body.style.overflowY = '';\n\n      // Get rects representing key elements\n      // Use getComputedStyle for arrowRect to avoid modifications made by transform\n      const viewportRect = getViewportRect(document.defaultView!);\n      const trackRect = getLogicalBoundingClientRect(track);\n      const arrowRect = getDimensions(arrow);\n      const containingBlock = getContainingBlock(popover);\n      const containingBlockRect = containingBlock ? getLogicalBoundingClientRect(containingBlock) : viewportRect;\n\n      const bodyBorderWidth = getBorderWidth(body);\n      const contentRect = getLogicalBoundingClientRect(contentRef.current);\n      const contentBoundingBox = {\n        inlineSize: contentRect.inlineSize + 2 * bodyBorderWidth,\n        blockSize: contentRect.blockSize + 2 * bodyBorderWidth,\n      };\n\n      // When keepPosition is true and the recalculation was triggered by a resize of the popover content,\n      // we maintain the previously defined internal position,\n      // but we still call calculatePosition to know if the popover should be scrollable.\n      const shouldKeepPosition = keepPosition && onContentResize && !!previousInternalPositionRef.current;\n      const fixedInternalPosition = (shouldKeepPosition && previousInternalPositionRef.current) ?? undefined;\n\n      // Calculate the arrow direction and viewport-relative position of the popover.\n      const {\n        scrollable,\n        internalPosition: newInternalPosition,\n        rect,\n      } = calculatePosition({\n        preferredPosition,\n        fixedInternalPosition,\n        trigger: trackRect,\n        arrow: arrowRect,\n        body: contentBoundingBox,\n        container: containingBlock ? containingBlockRect : getDocumentRect(document),\n        viewport: viewportRect,\n        renderWithPortal,\n        allowVerticalOverflow,\n      });\n\n      // Get the position of the popover relative to the offset parent.\n      const popoverOffset = toRelativePosition(rect, containingBlockRect);\n\n      // Cache the distance between the trigger and the popover (which stays the same as you scroll),\n      // and use that to recalculate the new popover position.\n      const trackRelativeOffset = toRelativePosition(popoverOffset, toRelativePosition(trackRect, containingBlockRect));\n\n      // Bring back the container to its original position to prevent any flashing.\n      popover.style.insetBlockStart = prevInsetBlockStart;\n      popover.style.insetInlineStart = prevInsetInlineStart;\n\n      // Allow popover body to scroll if can't fit the popover into the container/viewport otherwise.\n      if (scrollable) {\n        body.style.maxBlockSize = rect.blockSize + 'px';\n        body.style.overflowX = 'hidden';\n        body.style.overflowY = 'auto';\n      }\n\n      // Remember the internal position in case we want to keep it later.\n      previousInternalPositionRef.current = newInternalPosition;\n      setInternalPosition(newInternalPosition);\n\n      const shouldScroll = allowScrollToFit && !shouldKeepPosition;\n\n      // Position the popover\n      const insetBlockStart = shouldScroll\n        ? popoverOffset.insetBlockStart + calculateScroll(rect)\n        : popoverOffset.insetBlockStart;\n      setPopoverStyle({ insetBlockStart, insetInlineStart: popoverOffset.insetInlineStart });\n\n      // Scroll if necessary\n      if (shouldScroll) {\n        const scrollableParent = getFirstScrollableParent(popover);\n        scrollRectangleIntoView(rect, scrollableParent);\n      }\n\n      positionHandlerRef.current = () => {\n        const newTrackOffset = toRelativePosition(\n          getLogicalBoundingClientRect(track),\n          containingBlock ? getLogicalBoundingClientRect(containingBlock) : viewportRect\n        );\n        setPopoverStyle({\n          insetBlockStart: newTrackOffset.insetBlockStart + trackRelativeOffset.insetBlockStart,\n          insetInlineStart: newTrackOffset.insetInlineStart + trackRelativeOffset.insetInlineStart,\n        });\n      };\n    },\n    [\n      trackRef,\n      popoverRef,\n      bodyRef,\n      contentRef,\n      arrowRef,\n      keepPosition,\n      allowScrollToFit,\n      preferredPosition,\n      renderWithPortal,\n      allowVerticalOverflow,\n    ]\n  );\n  return { updatePositionHandler, popoverStyle, internalPosition, positionHandlerRef };\n}\n\nfunction getBorderWidth(element: HTMLElement) {\n  return parseInt(getComputedStyle(element).borderWidth) || 0;\n}\n\n/**\n * Convert a viewport-relative offset to an element-relative offset.\n */\nfunction toRelativePosition(element: Offset, parent: Offset): Offset {\n  return {\n    insetBlockStart: element.insetBlockStart - parent.insetBlockStart,\n    insetInlineStart: element.insetInlineStart - parent.insetInlineStart,\n  };\n}\n\n/**\n * Get a BoundingBox that represents the visible viewport.\n */\nfunction getViewportRect(window: Window): BoundingBox {\n  return {\n    insetBlockStart: 0,\n    insetInlineStart: 0,\n    inlineSize: window.innerWidth,\n    blockSize: window.innerHeight,\n  };\n}\n\nfunction getDocumentRect(document: Document): BoundingBox {\n  const { insetBlockStart, insetInlineStart } = getLogicalBoundingClientRect(document.documentElement);\n\n  return {\n    insetBlockStart,\n    insetInlineStart,\n    inlineSize: document.documentElement.scrollWidth,\n    blockSize: document.documentElement.scrollHeight,\n  };\n}\n"]}