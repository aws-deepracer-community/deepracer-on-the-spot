{"version":3,"file":"use-drag-and-drop-reorder.js","sourceRoot":"","sources":["../../../../src/collection-preferences/content-display/use-drag-and-drop-reorder.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport React, { useRef, useState } from 'react';\nimport {\n  Active,\n  closestCenter,\n  CollisionDetection,\n  DroppableContainer,\n  KeyboardCoordinateGetter,\n  PointerSensor,\n  UniqueIdentifier,\n  useSensor,\n  useSensors,\n} from '@dnd-kit/core';\nimport { CollectionPreferencesProps } from '../interfaces';\nimport { hasSortableData } from '@dnd-kit/sortable';\nimport { KeyboardSensor } from './keyboard-sensor';\n\nenum KeyboardCode {\n  Space = 'Space',\n  Down = 'ArrowDown',\n  Right = 'ArrowRight',\n  Left = 'ArrowLeft',\n  Up = 'ArrowUp',\n  Esc = 'Escape',\n  Enter = 'Enter',\n}\n\n// A custom collision detection algorithm is used when using a keyboard to\n// work around an unexpected behavior when reordering items of variable height\n// with the keyboard.\n\n// Neither closestCenter nor closestCorners work really well for this case,\n// because the center (or corners) of a tall rectangle might be so low that it\n// is detected as being closest to the rectangle below of the one it should\n// actually swap with.\n\n// Instead of relying on coordinates, the expected results are achieved by\n// moving X positions up or down in the initially sorted array, depending on\n// the desired direction.\n\n// We let our collisionDetection and customCoordinateGetter use the same\n// getClosestId function which takes its value from the current component\n// state, to make sure they are always in sync.\n\nexport default function useDragAndDropReorder({\n  sortedOptions,\n}: {\n  sortedOptions: ReadonlyArray<CollectionPreferencesProps.VisibleContentOption>;\n}) {\n  const isKeyboard = useRef(false);\n  const positionDelta = useRef(0);\n  const [activeItemId, setActiveItemId] = useState<UniqueIdentifier | null>(null);\n\n  const setActiveItem = (id: UniqueIdentifier | null) => {\n    setActiveItemId(id);\n    if (!id) {\n      isKeyboard.current = false;\n      positionDelta.current = 0;\n    }\n  };\n\n  const handleKeyDown = (event: React.KeyboardEvent) => {\n    if (isKeyboard.current && activeItemId) {\n      const currentTargetIndex = sortedOptions.findIndex(({ id }) => id === activeItemId) + positionDelta.current;\n      if (event.key === 'ArrowDown' && currentTargetIndex < sortedOptions.length - 1) {\n        positionDelta.current += 1;\n      } else if (event.key === 'ArrowUp' && currentTargetIndex > 0) {\n        positionDelta.current -= 1;\n      }\n    }\n    if (activeItemId && isEscape(event.key)) {\n      // Prevent modal from closing when pressing Esc to cancel the dragging action\n      event.stopPropagation();\n    }\n  };\n\n  const getClosestId = (active: Active) => {\n    if (positionDelta.current === 0) {\n      return active.id;\n    }\n    const currentIndex = sortedOptions.findIndex(({ id }) => id === active.id);\n    const newIndex = Math.max(0, Math.min(sortedOptions.length - 1, currentIndex + positionDelta.current));\n    return sortedOptions[newIndex].id;\n  };\n\n  const collisionDetection: CollisionDetection = ({\n    active,\n    collisionRect,\n    droppableContainers,\n    droppableRects,\n    pointerCoordinates,\n  }) => {\n    if (isKeyboard.current) {\n      // For keyboard interaction, determine the colliding container based on the movements made by the arrow keys,\n      // via getClosestId\n      const collidingContainer = getCollidingContainer({\n        activeId: active.id,\n        closestId: getClosestId(active),\n        droppableContainers,\n      });\n      return collidingContainer ? [collidingContainer] : [];\n    } else {\n      // For mouse interaction, use the closest center algorithm\n      return closestCenter({ active, collisionRect, droppableRects, droppableContainers, pointerCoordinates });\n    }\n  };\n\n  const coordinateGetter: KeyboardCoordinateGetter = (\n    event,\n    { context: { active, collisionRect, droppableRects, droppableContainers } }\n  ) => {\n    if (event.code === KeyboardCode.Up || event.code === KeyboardCode.Down) {\n      event.preventDefault();\n\n      if (!active || !collisionRect) {\n        return;\n      }\n\n      const closestId = getClosestId(active);\n\n      if (closestId !== null) {\n        const activeDroppable = droppableContainers.get(active.id);\n        const newDroppable = droppableContainers.get(closestId);\n        const newRect = newDroppable ? droppableRects.get(newDroppable.id) : null;\n        const newNode = newDroppable?.node.current;\n\n        if (newNode && newRect && activeDroppable && newDroppable) {\n          const isAfterActive = isAfter(activeDroppable, newDroppable);\n          const offset = {\n            x: isAfterActive ? collisionRect.width - newRect.width : 0,\n            y: isAfterActive ? collisionRect.height - newRect.height : 0,\n          };\n          const rectCoordinates = {\n            x: newRect.left,\n            y: newRect.top,\n          };\n\n          return {\n            x: rectCoordinates.x - offset.x,\n            y: rectCoordinates.y - offset.y,\n          };\n        }\n      }\n    }\n  };\n\n  const sensors = useSensors(\n    useSensor(PointerSensor),\n    useSensor(KeyboardSensor, {\n      coordinateGetter,\n      onActivation: () => {\n        isKeyboard.current = true;\n      },\n    })\n  );\n\n  return {\n    activeItem: activeItemId,\n    collisionDetection,\n    coordinateGetter,\n    handleKeyDown,\n    sensors,\n    setActiveItem,\n  };\n}\n\nfunction isAfter(a: DroppableContainer, b: DroppableContainer) {\n  return hasSortableData(a) && hasSortableData(b) && a.data.current.sortable.index < b.data.current.sortable.index;\n}\n\nfunction getCollidingContainer({\n  activeId,\n  closestId,\n  droppableContainers,\n}: {\n  activeId: UniqueIdentifier;\n  closestId: UniqueIdentifier;\n  droppableContainers: DroppableContainer[];\n}) {\n  if (closestId === activeId) {\n    return;\n  }\n  const collidingContainer = droppableContainers.find(({ id }) => id === closestId);\n  if (collidingContainer) {\n    return {\n      id: collidingContainer.id,\n      data: {\n        droppableContainer: collidingContainer,\n        value: 0,\n      },\n    };\n  }\n}\n\nconst isEscape = (key: string) => key === 'Escape' || key === 'Esc';\n"]}