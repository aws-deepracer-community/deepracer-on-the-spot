{"version":3,"file":"animate.js","sourceRoot":"","sources":["../../../src/internal/animate.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nexport function getDOMRects(elements: Record<string, HTMLElement | null>) {\n  const rects: Record<string, DOMRect> = {};\n  for (const id in elements) {\n    const element = elements[id];\n    if (element) {\n      rects[id] = element.getBoundingClientRect();\n    }\n  }\n  return rects;\n}\n\n/*\n  Animate DOM elements based on the FLIP technique\n  - https://aerotwist.com/blog/flip-your-animations/\n  - https://css-tricks.com/animating-layouts-with-the-flip-technique/\n\n  This can be useful when the initial dimensions or position of the element is not known,\n  so the initial offset or scaling needs to be retrieved via JS.\n\n  Caveat: this currently does not support elements having CSS transforms in the end state.\n  These would be overridden in the animation instead of combined.\n */\nexport function animate({\n  oldState,\n  elements,\n  onTransitionsEnd,\n  newElementInitialState,\n}: {\n  elements: Record<string, HTMLElement | null>;\n  oldState: Record<string, DOMRect>;\n  onTransitionsEnd?: () => void;\n  newElementInitialState?: (newRect: DOMRect) => { scale?: number; y?: number };\n}) {\n  // First, apply the transform that will make the elements \"look like\" in the start position\n  for (const id in elements) {\n    const element = elements[id];\n    const oldRect = oldState[id];\n    if (element) {\n      const newRect = element.getBoundingClientRect();\n      const noOpTransform = { scale: 1, x: 0, y: 0 };\n      // Calculate initial position.\n      // If the element didn't exist previously, use the newElementInitialState function if provided.\n      // If not, default to no transitions (scale: 1, y: 0)\n      const calculatedInverseTransform = oldRect\n        ? {\n            scale: oldRect.width / newRect.width,\n            x: (oldRect.left + oldRect.right) / 2 - (newRect.left + newRect.right) / 2,\n            y: (oldRect.top + oldRect.bottom) / 2 - (newRect.top + newRect.bottom) / 2,\n          }\n        : newElementInitialState\n        ? newElementInitialState(newRect)\n        : {};\n      const inverseTransform = { ...noOpTransform, ...calculatedInverseTransform };\n      // Apply this initial change, without animating\n      element.style.transitionProperty = 'none';\n      element.style.transform = `scale(${inverseTransform.scale}) translate(${inverseTransform.x}px, ${inverseTransform.y}px)`;\n      if (!oldRect) {\n        // If the element didn't exist, then fade it in\n        // (besides any other possibly defined transitions based on `newElementInitialState`)\n        element.style.opacity = '0';\n      }\n    }\n  }\n\n  // Animate from the initial state to the end state\n  requestAnimationFrame(() => {\n    const ongoingAnimations = new Set();\n    for (const id in elements) {\n      const element = elements[id];\n      if (element) {\n        const oldRect = oldState[id];\n        if (oldRect) {\n          // Animate from here on\n          element.style.transitionProperty = `transform`;\n          // Unset inline CSS transforms so that the final state is applied\n          element.style.transform = '';\n        } else {\n          // If the element didn't exist previously, fade in as well\n          element.style.transitionProperty = `transform, opacity`;\n          element.style.transform = '';\n          element.style.opacity = '';\n        }\n        const onTransitionStart = (event: TransitionEvent) => {\n          if (event.target === element) {\n            ongoingAnimations.add(id);\n            element.removeEventListener('transitionstart', onTransitionStart);\n          }\n        };\n        const onTransitionEnd = (event: TransitionEvent) => {\n          if (event.target === element) {\n            // Clean up remaining inline styles\n            element.style.transitionProperty = '';\n            element.removeEventListener('transitionstart', onTransitionEnd);\n            if (onTransitionsEnd) {\n              ongoingAnimations.delete(id);\n              if (ongoingAnimations.size === 0) {\n                onTransitionsEnd();\n              }\n            }\n          }\n        };\n        element.addEventListener('transitionstart', onTransitionStart);\n        element.addEventListener('transitionend', onTransitionEnd);\n      }\n    }\n  });\n}\n"]}