{"version":3,"file":"direction.js","sourceRoot":"","sources":["../../../src/internal/direction.ts"],"names":[],"mappings":"AAAA,qEAAqE;AACrE,sCAAsC;AAEtC,MAAM,UAAU,KAAK,CAAC,OAAiC;IACrD,OAAO,gBAAgB,CAAC,OAAO,CAAC,CAAC,SAAS,KAAK,KAAK,CAAC;AACvD,CAAC;AAED;;;;;GAKG;AACH,MAAM,UAAU,oBAAoB,CAAC,OAAoB;IACvD,OAAO,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,UAAU,CAAC,CAAC;AAC9F,CAAC;AAED;;;;;GAKG;AACH,MAAM,UAAU,4BAA4B,CAAC,OAAiC;IAC5E,MAAM,kBAAkB,GAAG,OAAO,CAAC,qBAAqB,EAAE,CAAC;IAE3D,MAAM,SAAS,GAAG,kBAAkB,CAAC,MAAM,CAAC;IAC5C,MAAM,UAAU,GAAG,kBAAkB,CAAC,KAAK,CAAC;IAC5C,MAAM,eAAe,GAAG,kBAAkB,CAAC,GAAG,CAAC;IAC/C,MAAM,aAAa,GAAG,kBAAkB,CAAC,MAAM,CAAC;IAChD,MAAM,gBAAgB,GAAG,KAAK,CAAC,OAAO,CAAC;QACrC,CAAC,CAAC,QAAQ,CAAC,eAAe,CAAC,WAAW,GAAG,kBAAkB,CAAC,KAAK;QACjE,CAAC,CAAC,kBAAkB,CAAC,IAAI,CAAC;IAC5B,MAAM,cAAc,GAAG,gBAAgB,GAAG,UAAU,CAAC;IAErD,OAAO;QACL,SAAS;QACT,UAAU;QACV,eAAe;QACf,aAAa;QACb,gBAAgB;QAChB,cAAc;KACf,CAAC;AACJ,CAAC","sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nexport function isRtl(element: HTMLElement | SVGElement) {\n  return getComputedStyle(element).direction === 'rtl';\n}\n\n/**\n * The scrollLeft value will be a negative number if the direction is RTL and\n * needs to be converted to a positive value for direction independent scroll\n * computations. Additionally, the scrollLeft value can be a decimal value on\n * systems using display scaling requiring the floor and ceiling calls.\n */\nexport function getScrollInlineStart(element: HTMLElement) {\n  return isRtl(element) ? Math.floor(element.scrollLeft) * -1 : Math.ceil(element.scrollLeft);\n}\n\n/**\n * The getBoundingClientRect() function returns values relative to the top left\n * corner of the document regardless of document direction. The left/right position\n * will be transformed to insetInlineStart based on element direction in order to\n * support direction agnostic position computation.\n */\nexport function getLogicalBoundingClientRect(element: HTMLElement | SVGElement) {\n  const boundingClientRect = element.getBoundingClientRect();\n\n  const blockSize = boundingClientRect.height;\n  const inlineSize = boundingClientRect.width;\n  const insetBlockStart = boundingClientRect.top;\n  const insetBlockEnd = boundingClientRect.bottom;\n  const insetInlineStart = isRtl(element)\n    ? document.documentElement.clientWidth - boundingClientRect.right\n    : boundingClientRect.left;\n  const insetInlineEnd = insetInlineStart + inlineSize;\n\n  return {\n    blockSize,\n    inlineSize,\n    insetBlockStart,\n    insetBlockEnd,\n    insetInlineStart,\n    insetInlineEnd,\n  };\n}\n"]}