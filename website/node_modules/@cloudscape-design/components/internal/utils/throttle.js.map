{"version":3,"file":"throttle.js","sourceRoot":"","sources":["../../../../src/internal/utils/throttle.ts"],"names":[],"mappings":"AAAA,qEAAqE;AACrE,sCAAsC;AAYtC,MAAM,UAAU,QAAQ,CACtB,IAAO,EACP,KAAa,EACb,EAAE,QAAQ,GAAG,IAAI,KAAsB,EAAE;IAEzC,IAAI,OAAO,GAAoC,IAAI,CAAC;IACpD,IAAI,cAAc,GAAkB,IAAI,CAAC;IACzC,IAAI,OAAO,GAAkB,IAAI,CAAC;IAElC,qDAAqD;IACrD,SAAS,WAAW;QAClB,IAAI,OAAO,KAAK,IAAI,IAAI,cAAc,KAAK,IAAI,EAAE;YAC/C,OAAO;SACR;QAED,MAAM,UAAU,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;QAC9B,MAAM,YAAY,GAAG,UAAU,GAAG,cAAc,IAAI,KAAK,CAAC;QAE1D,IAAI,YAAY,EAAE;YAChB,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,IAAI,EAAE,OAAO,CAAC,IAAI,CAAC,CAAC;YACvC,cAAc,GAAG,UAAU,CAAC;YAC5B,OAAO,GAAG,IAAI,CAAC;YACf,OAAO,GAAG,IAAI,CAAC;SAChB;aAAM,IAAI,QAAQ,EAAE;YACnB,UAAU,EAAE,CAAC;SACd;IACH,CAAC;IAED,SAAS,UAAU;QACjB,IAAI,OAAO,EAAE;YACX,oBAAoB,CAAC,OAAO,CAAC,CAAC;SAC/B;QACD,OAAO,GAAG,qBAAqB,CAAC,WAAW,CAAC,CAAC;IAC/C,CAAC;IAED,kDAAkD;IAClD,SAAS,SAAS,CAAY,GAAG,IAAS;QACxC,IAAI,cAAc,KAAK,IAAI,EAAE;YAC3B,cAAc,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;YAC5B,IAAI,CAAC,KAAK,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC;SACxB;aAAM;YACL,OAAO,GAAG,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,CAAC;YAC/B,UAAU,EAAE,CAAC;SACd;IACH,CAAC;IAED,kEAAkE;IAClE,SAAS,CAAC,MAAM,GAAG,GAAG,EAAE;QACtB,IAAI,OAAO,EAAE;YACX,oBAAoB,CAAC,OAAO,CAAC,CAAC;SAC/B;QACD,OAAO,GAAG,IAAI,CAAC;QACf,cAAc,GAAG,IAAI,CAAC;QACtB,OAAO,GAAG,IAAI,CAAC;IACjB,CAAC,CAAC;IAEF,OAAO,SAAS,CAAC;AACnB,CAAC","sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nexport interface ThrottleOptions {\n  leading?: boolean;\n  trailing?: boolean;\n}\n\nexport interface ThrottledFunction<F extends (...args: any) => any> {\n  (...args: Parameters<F>): void;\n  cancel(): void;\n}\n\nexport function throttle<F extends (...args: any) => any>(\n  func: F,\n  delay: number,\n  { trailing = true }: ThrottleOptions = {}\n): ThrottledFunction<F> {\n  let pending: null | { this: any; args: any } = null;\n  let lastInvokeTime: null | number = null;\n  let timerId: null | number = null;\n\n  // Runs on every animation frame until timer stopped.\n  function pendingFunc() {\n    if (pending === null || lastInvokeTime === null) {\n      return;\n    }\n\n    const invokeTime = Date.now();\n    const shouldInvoke = invokeTime - lastInvokeTime >= delay;\n\n    if (shouldInvoke) {\n      func.apply(pending.this, pending.args);\n      lastInvokeTime = invokeTime;\n      pending = null;\n      timerId = null;\n    } else if (trailing) {\n      startTimer();\n    }\n  }\n\n  function startTimer() {\n    if (timerId) {\n      cancelAnimationFrame(timerId);\n    }\n    timerId = requestAnimationFrame(pendingFunc);\n  }\n\n  // Decorated client function with delay mechanism.\n  function throttled(this: any, ...args: any) {\n    if (lastInvokeTime === null) {\n      lastInvokeTime = Date.now();\n      func.apply(this, args);\n    } else {\n      pending = { this: this, args };\n      startTimer();\n    }\n  }\n\n  // Prevents delayed function from execution when no longer needed.\n  throttled.cancel = () => {\n    if (timerId) {\n      cancelAnimationFrame(timerId);\n    }\n    pending = null;\n    lastInvokeTime = null;\n    timerId = null;\n  };\n\n  return throttled;\n}\n"]}