{"version":3,"file":"scrollable-containers.js","sourceRoot":"","sources":["../../../../src/internal/utils/scrollable-containers.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { findUpUntil } from './dom';\nexport interface BoundingBox {\n  blockSize: number;\n  inlineSize: number;\n  insetBlockStart: number;\n  insetInlineStart: number;\n}\n\nexport const getOverflowParents = (element: HTMLElement): HTMLElement[] => {\n  const parents = [];\n  let node: HTMLElement | null = element;\n\n  while ((node = node.parentElement) && node !== document.body) {\n    getComputedStyle(node).overflow !== 'visible' && parents.push(node);\n  }\n  return parents;\n};\n\nexport const getOverflowParentDimensions = ({\n  element,\n  excludeClosestParent = false,\n  expandToViewport = false,\n  canExpandOutsideViewport = false,\n}: {\n  element: HTMLElement;\n  excludeClosestParent: boolean;\n  expandToViewport: boolean;\n  canExpandOutsideViewport: boolean;\n}): BoundingBox[] => {\n  const parents = expandToViewport\n    ? []\n    : getOverflowParents(element).map(el => {\n        const { height, width, top, left } = el.getBoundingClientRect();\n        return {\n          // Treat the whole scrollable area as the available height\n          // if we're allowed to expand past the viewport.\n          blockSize: canExpandOutsideViewport ? el.scrollHeight : height,\n          inlineSize: width,\n          insetBlockStart: top,\n          insetInlineStart: left,\n        };\n      });\n\n  if (canExpandOutsideViewport && !expandToViewport) {\n    const documentDimensions = document.documentElement.getBoundingClientRect();\n    parents.push({\n      inlineSize: Math.max(documentDimensions.width, document.documentElement.clientWidth),\n      blockSize: Math.max(documentDimensions.height, document.documentElement.clientHeight),\n      insetBlockStart: documentDimensions.top,\n      insetInlineStart: documentDimensions.left,\n    });\n  } else {\n    parents.push({\n      blockSize: window.innerHeight,\n      inlineSize: window.innerWidth,\n      insetBlockStart: 0,\n      insetInlineStart: 0,\n    });\n  }\n\n  if (excludeClosestParent && !expandToViewport) {\n    parents.shift();\n  }\n\n  return parents;\n};\n\ntype ScrollIntoViewOptions = Parameters<HTMLElement['scrollIntoView']>[0];\n\n/**\n * Calls `scrollIntoView` on the provided element with sensible defaults. If\n * the element does not exist or does not support the `scrollIntoView`\n * method, it will do nothing. This wrapper is created to support environments\n * where the native function is not available like JSDom (feature request:\n * https://github.com/jsdom/jsdom/issues/1422).\n *\n * @param element to be scrolled into view\n * @param options native options for `scrollIntoView`\n */\nexport function scrollElementIntoView(\n  element: HTMLElement | undefined,\n  options: ScrollIntoViewOptions = { block: 'nearest', inline: 'nearest' }\n) {\n  element?.scrollIntoView?.(options);\n}\n\nexport function calculateScroll({ insetBlockStart, blockSize }: BoundingBox) {\n  if (insetBlockStart < 0) {\n    return insetBlockStart;\n  } else if (insetBlockStart + blockSize > window.innerHeight) {\n    if (blockSize > window.innerHeight) {\n      return insetBlockStart;\n    } else {\n      return insetBlockStart + blockSize - window.innerHeight;\n    }\n  }\n  return 0;\n}\n\n/**\n * For elements with fixed position, the browser's native scrollIntoView API doesn't work,\n * so we need to manually scroll to the element's position.\n * Supports only vertical scrolling.\n */\nexport function scrollRectangleIntoView(box: BoundingBox, scrollableParent?: HTMLElement) {\n  const scrollAmount = calculateScroll(box);\n  if (scrollAmount) {\n    (scrollableParent || window).scrollBy(0, scrollAmount);\n  }\n}\n\nexport function getFirstScrollableParent(element: HTMLElement): HTMLElement | undefined {\n  return (\n    findUpUntil(element, el => {\n      const overflows = el.scrollHeight > el.clientHeight;\n      return overflows && ['scroll', 'auto'].includes(getComputedStyle(el).overflowY);\n    }) || undefined\n  );\n}\n"]}