// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
import { useCallback, useEffect, useRef } from 'react';
export function useFocusControl(isOpen, restoreFocus = false, activeDrawerId) {
    const refs = {
        toggle: useRef(null),
        close: useRef(null),
        slider: useRef(null),
    };
    const previousFocusedElement = useRef();
    const shouldFocus = useRef(false);
    const doFocus = () => {
        var _a, _b, _c;
        if (!shouldFocus.current) {
            return;
        }
        if (isOpen) {
            previousFocusedElement.current =
                document.activeElement !== document.body ? document.activeElement : undefined;
            if (refs.slider.current) {
                (_a = refs.slider.current) === null || _a === void 0 ? void 0 : _a.focus();
            }
            else {
                (_b = refs.close.current) === null || _b === void 0 ? void 0 : _b.focus();
            }
        }
        else {
            if (restoreFocus && previousFocusedElement.current && document.contains(previousFocusedElement.current)) {
                previousFocusedElement.current.focus();
                previousFocusedElement.current = undefined;
            }
            else {
                (_c = refs.toggle.current) === null || _c === void 0 ? void 0 : _c.focus();
            }
        }
        shouldFocus.current = false;
    };
    const setFocus = (force) => {
        shouldFocus.current = true;
        if (force && isOpen) {
            doFocus();
        }
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
    useEffect(doFocus, [isOpen, activeDrawerId]);
    const loseFocus = useCallback(() => {
        previousFocusedElement.current = undefined;
    }, []);
    return {
        refs,
        setFocus,
        loseFocus,
    };
}
//# sourceMappingURL=use-focus-control.js.map