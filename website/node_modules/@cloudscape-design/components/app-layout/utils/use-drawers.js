// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
import { useEffect, useRef, useState } from 'react';
import { useStableCallback } from '@cloudscape-design/component-toolkit/internal';
import { useControllable } from '../../internal/hooks/use-controllable';
import { fireNonCancelableEvent } from '../../internal/events';
import { awsuiPluginsInternal } from '../../internal/plugins/api';
import { sortByPriority } from '../../internal/plugins/helpers/utils';
import { convertRuntimeDrawers } from '../runtime-api';
import { togglesConfig } from '../toggles';
export const TOOLS_DRAWER_ID = 'awsui-internal-tools';
function getToolsDrawerItem(props) {
    if (props.toolsHide) {
        return null;
    }
    const { iconName, getLabels } = togglesConfig.tools;
    const { mainLabel, closeLabel, openLabel } = getLabels(props.ariaLabels);
    return {
        id: TOOLS_DRAWER_ID,
        content: props.tools,
        resizable: false,
        ariaLabels: {
            triggerButton: openLabel,
            closeButton: closeLabel,
            drawerName: mainLabel !== null && mainLabel !== void 0 ? mainLabel : '',
        },
        trigger: {
            iconName: iconName,
        },
    };
}
function useRuntimeDrawers(disableRuntimeDrawers, activeDrawerId, onActiveDrawerChange) {
    const [runtimeDrawers, setRuntimeDrawers] = useState({ before: [], after: [] });
    const onActiveDrawerChangeStable = useStableCallback(onActiveDrawerChange);
    const drawerWasOpenRef = useRef(false);
    drawerWasOpenRef.current = drawerWasOpenRef.current || !!activeDrawerId;
    useEffect(() => {
        if (disableRuntimeDrawers) {
            return;
        }
        const unsubscribe = awsuiPluginsInternal.appLayout.onDrawersRegistered(drawers => {
            setRuntimeDrawers(convertRuntimeDrawers(drawers));
            if (!drawerWasOpenRef.current) {
                const defaultActiveDrawer = sortByPriority(drawers).find(drawer => drawer.defaultActive);
                if (defaultActiveDrawer) {
                    onActiveDrawerChangeStable(defaultActiveDrawer.id);
                }
            }
        });
        return () => {
            unsubscribe();
            setRuntimeDrawers({ before: [], after: [] });
        };
    }, [disableRuntimeDrawers, onActiveDrawerChangeStable]);
    return runtimeDrawers;
}
function applyToolsDrawer(toolsProps, runtimeDrawers) {
    const drawers = [...runtimeDrawers.before, ...runtimeDrawers.after];
    if (drawers.length === 0) {
        return null;
    }
    const toolsItem = getToolsDrawerItem(toolsProps);
    if (toolsItem) {
        drawers.unshift(toolsItem);
    }
    return drawers;
}
export function useDrawers({ drawers, activeDrawerId: controlledActiveDrawerId, onDrawerChange, __disableRuntimeDrawers: disableRuntimeDrawers, }, ariaLabels, toolsProps) {
    var _a, _b, _c, _d;
    const [activeDrawerId = null, setActiveDrawerId] = useControllable(controlledActiveDrawerId, onDrawerChange, null, {
        componentName: 'AppLayout',
        controlledProp: 'activeDrawerId',
        changeHandler: 'onChange',
    });
    const [drawerSizes, setDrawerSizes] = useState({});
    function onActiveDrawerResize({ id, size }) {
        setDrawerSizes(oldSizes => (Object.assign(Object.assign({}, oldSizes), { [id]: size })));
        fireNonCancelableEvent(activeDrawer === null || activeDrawer === void 0 ? void 0 : activeDrawer.onResize, { id, size });
    }
    function onActiveDrawerChange(newDrawerId) {
        setActiveDrawerId(newDrawerId);
        if (hasOwnDrawers) {
            fireNonCancelableEvent(onDrawerChange, { activeDrawerId: newDrawerId });
        }
        else if (!toolsProps.toolsHide) {
            toolsProps.onToolsToggle(newDrawerId === TOOLS_DRAWER_ID);
        }
    }
    const hasOwnDrawers = !!drawers;
    const runtimeDrawers = useRuntimeDrawers(disableRuntimeDrawers, activeDrawerId, onActiveDrawerChange);
    const combinedDrawers = drawers
        ? [...runtimeDrawers.before, ...drawers, ...runtimeDrawers.after]
        : applyToolsDrawer(toolsProps, runtimeDrawers);
    // support toolsOpen in runtime-drawers-only mode
    let activeDrawerIdResolved = (toolsProps === null || toolsProps === void 0 ? void 0 : toolsProps.toolsOpen) && !hasOwnDrawers ? TOOLS_DRAWER_ID : activeDrawerId;
    const activeDrawer = combinedDrawers === null || combinedDrawers === void 0 ? void 0 : combinedDrawers.find(drawer => drawer.id === activeDrawerIdResolved);
    // ensure that id is only defined when the drawer exists
    activeDrawerIdResolved = (_a = activeDrawer === null || activeDrawer === void 0 ? void 0 : activeDrawer.id) !== null && _a !== void 0 ? _a : null;
    const activeDrawerSize = activeDrawerIdResolved
        ? (_c = (_b = drawerSizes[activeDrawerIdResolved]) !== null && _b !== void 0 ? _b : activeDrawer === null || activeDrawer === void 0 ? void 0 : activeDrawer.defaultSize) !== null && _c !== void 0 ? _c : toolsProps.toolsWidth
        : toolsProps.toolsWidth;
    const minDrawerSize = Math.min((_d = activeDrawer === null || activeDrawer === void 0 ? void 0 : activeDrawer.defaultSize) !== null && _d !== void 0 ? _d : 290, 290);
    return {
        ariaLabelsWithDrawers: ariaLabels,
        drawers: combinedDrawers || undefined,
        activeDrawer,
        activeDrawerId: activeDrawerIdResolved,
        activeDrawerSize,
        minDrawerSize,
        onActiveDrawerChange,
        onActiveDrawerResize,
    };
}
//# sourceMappingURL=use-drawers.js.map