{"version":3,"file":"utils.js","sourceRoot":"","sources":["../../../src/flashbar/utils.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { FlashbarProps } from './interfaces';\nimport { IconProps } from '../icon/interfaces';\n\nexport const FOCUS_THROTTLE_DELAY = 2000;\n\n// Since the position of a notification changes when the Flashbar is collapsed,\n// it is useful on some situations (e.g, for animating) to know the original position of the item\n// in the non-collapsed state.\nexport interface StackableItem extends FlashbarProps.MessageDefinition {\n  expandedIndex: number;\n  collapsedIndex?: number;\n}\n\nconst typesToColors: Record<FlashbarProps.Type, string> = {\n  error: 'red',\n  info: 'blue',\n  'in-progress': 'blue',\n  success: 'green',\n  warning: 'yellow',\n};\n\nfunction getColorFromType(type?: FlashbarProps.Type): string {\n  const defaultColor = 'blue';\n  return type ? typesToColors[type] || defaultColor : defaultColor;\n}\n\nexport function getItemType(item: FlashbarProps.MessageDefinition) {\n  if (item.loading) {\n    return 'in-progress';\n  } else {\n    return item.type || 'info';\n  }\n}\n\nexport function getItemColor(item: FlashbarProps.MessageDefinition) {\n  return getColorFromType(getItemType(item));\n}\n\n/*\n Returns a selection of notifications, preserving the order when possible but making sure that all different colors in\n the stack are represented in the returned array.\n The order corresponds to how they are represented when using the collapsible feature (newest first, oldest last).\n */\nexport function getVisibleCollapsedItems(\n  items: ReadonlyArray<FlashbarProps.MessageDefinition>,\n  desiredLength: number\n): ReadonlyArray<StackableItem> {\n  // First `desiredLength` items in the original array,\n  // together with `isColorRepeated` to tell if they can be subject to be replaced later on if necessary\n  const itemsOnTop: { item: StackableItem; isColorRepeated: boolean }[] = [];\n\n  // Items that fall outside `desiredIndexLength` but need to be \"promoted\" if possible\n  // because they are of a different color which otherwise wouldn't be represented\n  const itemsToPromote: StackableItem[] = [];\n\n  const addedColors: Set<string> = new Set();\n  const allPossibleColors = Object.keys(typesToColors).length;\n  const finalLength = Math.min(items.length, desiredLength);\n\n  for (let i = 0; i < items.length; i++) {\n    const item = items[i];\n    const color = getItemColor(item);\n    const isColorRepeated = addedColors.has(color);\n    if (i < finalLength) {\n      itemsOnTop.push({ item: { ...item, expandedIndex: i }, isColorRepeated });\n    } else {\n      if (addedColors.size === allPossibleColors) {\n        // No need to keep looking for unrepresented colors, we can stop looping\n        break;\n      } else if (!isColorRepeated) {\n        itemsToPromote.push({ ...item, expandedIndex: i });\n      }\n    }\n    addedColors.add(color);\n  }\n  // Generate the new array with the selected items, by picking from both arrays.\n  // First, from the non-repeated items within the desired length...\n  // We loop `itemsOnTop` starting from the end because we prefer to preserve the first ones rather than the old ones\n  const reversedInitialSelection = [];\n  let slotsReservedForPromotions = 0;\n  for (let j = itemsOnTop.length - 1; j >= 0; j--) {\n    const item = itemsOnTop[j];\n    if (item.isColorRepeated && slotsReservedForPromotions < itemsToPromote.length) {\n      slotsReservedForPromotions += 1;\n    } else {\n      reversedInitialSelection.push(item.item);\n    }\n  }\n  const selectedItems = reversedInitialSelection.reverse();\n  // ...and then complete the selection with as many promotable items as we can fit in the rest of the array\n  for (let k = 0; selectedItems.length < desiredLength; k++) {\n    selectedItems.push(itemsToPromote[k]);\n  }\n  return selectedItems;\n}\n\nexport function getFlashTypeCount(\n  items: readonly FlashbarProps.MessageDefinition[]\n): Record<FlashbarProps.Type, number> {\n  const count = { error: 0, info: 0, 'in-progress': 0, success: 0, warning: 0 };\n  for (const item of items) {\n    const type = getItemType(item);\n    count[type] += 1;\n  }\n  return count;\n}\n\nexport type LabelName =\n  | 'errorIconAriaLabel'\n  | 'warningIconAriaLabel'\n  | 'successIconAriaLabel'\n  | 'infoIconAriaLabel'\n  | 'inProgressIconAriaLabel';\n\nexport const counterTypes: {\n  type: FlashbarProps.Type;\n  labelName: LabelName;\n  iconName: IconProps.Name;\n}[] = [\n  { type: 'error', labelName: 'errorIconAriaLabel', iconName: 'status-negative' },\n  { type: 'warning', labelName: 'warningIconAriaLabel', iconName: 'status-warning' },\n  { type: 'success', labelName: 'successIconAriaLabel', iconName: 'status-positive' },\n  { type: 'info', labelName: 'infoIconAriaLabel', iconName: 'status-info' },\n  { type: 'in-progress', labelName: 'inProgressIconAriaLabel', iconName: 'status-in-progress' },\n];\n"]}