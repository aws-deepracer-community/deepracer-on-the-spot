// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
import React, { useState, useRef } from 'react';
import InternalSelect from '../select/internal';
import InternalAutosuggest from '../autosuggest/internal';
import InternalPopover from '../popover/internal';
import styles from './styles.css.js';
import { useLoadItems } from './use-load-items';
import { createPropertiesCompatibilityMap, getAllowedOperators, operatorToDescription, getPropertySuggestions, } from './controller';
import InternalButton from '../button/internal';
import InternalFormField from '../form-field/internal';
import { matchTokenValue } from './utils';
function PropertyInput({ property, onChangePropertyKey, asyncProps, filteringProperties, onLoadItems, customGroupsText, i18nStrings, freeTextFiltering, }) {
    var _a;
    const propertySelectHandlers = useLoadItems(onLoadItems);
    const asyncPropertySelectProps = asyncProps ? Object.assign(Object.assign({}, asyncProps), propertySelectHandlers) : {};
    const propertyOptions = getPropertySuggestions(filteringProperties, customGroupsText, i18nStrings, ({ propertyKey, propertyLabel }) => ({
        value: propertyKey,
        label: propertyLabel,
        dontCloseOnSelect: true,
    }));
    // Disallow selecting properties that have different representation.
    const checkPropertiesCompatible = createPropertiesCompatibilityMap(filteringProperties);
    propertyOptions.forEach(optionGroup => {
        if ('options' in optionGroup) {
            optionGroup.options.forEach(option => {
                if ((property === null || property === void 0 ? void 0 : property.propertyKey) && option.value) {
                    option.disabled = !checkPropertiesCompatible(option.value, property.propertyKey);
                }
            });
        }
    });
    const allPropertiesOption = {
        label: i18nStrings.allPropertiesLabel,
        value: undefined,
    };
    if (!freeTextFiltering.disabled) {
        propertyOptions.unshift(allPropertiesOption);
    }
    return (React.createElement(InternalSelect, Object.assign({ options: propertyOptions, selectedOption: property
            ? {
                value: (_a = property.propertyKey) !== null && _a !== void 0 ? _a : undefined,
                label: property.propertyLabel,
            }
            : allPropertiesOption, onChange: e => onChangePropertyKey(e.detail.selectedOption.value) }, asyncPropertySelectProps)));
}
function OperatorInput({ property, operator, onChangeOperator, i18nStrings, freeTextFiltering }) {
    const operatorOptions = (property ? getAllowedOperators(property) : freeTextFiltering.operators).map(operator => ({
        value: operator,
        label: operator,
        description: operatorToDescription(operator, i18nStrings),
    }));
    return (React.createElement(InternalSelect, { options: operatorOptions, triggerVariant: "option", selectedOption: operator
            ? {
                value: operator,
                label: operator,
                description: operatorToDescription(operator, i18nStrings),
            }
            : null, onChange: e => onChangeOperator(e.detail.selectedOption.value) }));
}
function ValueInput({ property, operator, value, onChangeValue, asyncProps, filteringOptions, onLoadItems, i18nStrings, }) {
    var _a, _b, _c;
    const valueOptions = property
        ? filteringOptions
            .filter(option => { var _a; return ((_a = option.property) === null || _a === void 0 ? void 0 : _a.propertyKey) === property.propertyKey; })
            .map(({ label, value }) => ({ label, value }))
        : [];
    const valueAutosuggestHandlers = useLoadItems(onLoadItems, '', property === null || property === void 0 ? void 0 : property.externalProperty);
    const asyncValueAutosuggestProps = (property === null || property === void 0 ? void 0 : property.propertyKey)
        ? Object.assign(Object.assign({}, valueAutosuggestHandlers), asyncProps) : { empty: asyncProps.empty };
    const [matchedOption] = valueOptions.filter(option => option.value === value);
    const OperatorForm = (property === null || property === void 0 ? void 0 : property.propertyKey) && operator && (property === null || property === void 0 ? void 0 : property.getValueFormRenderer(operator));
    return OperatorForm ? (React.createElement(OperatorForm, { value: value, onChange: onChangeValue, operator: operator })) : (React.createElement(InternalAutosuggest, Object.assign({ enteredTextLabel: (_a = i18nStrings.enteredTextLabel) !== null && _a !== void 0 ? _a : (value => value), value: (_c = (_b = matchedOption === null || matchedOption === void 0 ? void 0 : matchedOption.label) !== null && _b !== void 0 ? _b : value) !== null && _c !== void 0 ? _c : '', clearAriaLabel: i18nStrings.clearAriaLabel, onChange: e => onChangeValue(e.detail.value), disabled: !operator, options: valueOptions }, asyncValueAutosuggestProps, { virtualScroll: true })));
}
export function TokenEditor({ asyncProperties, asyncProps, customGroupsText, freeTextFiltering, expandToViewport, filteringProperties, filteringOptions, i18nStrings, onLoadItems, setToken, token, triggerComponent, }) {
    const [temporaryToken, setTemporaryToken] = useState(token);
    const popoverRef = useRef(null);
    const closePopover = () => {
        popoverRef.current && popoverRef.current.dismissPopover();
    };
    const property = temporaryToken.property;
    const onChangePropertyKey = (newPropertyKey) => {
        var _a;
        const filteringProperty = filteringProperties.reduce((acc, property) => (property.propertyKey === newPropertyKey ? property : acc), undefined);
        const allowedOperators = filteringProperty ? getAllowedOperators(filteringProperty) : freeTextFiltering.operators;
        const operator = temporaryToken.operator && allowedOperators.indexOf(temporaryToken.operator) !== -1
            ? temporaryToken.operator
            : allowedOperators[0];
        const matchedProperty = (_a = filteringProperties.find(property => property.propertyKey === newPropertyKey)) !== null && _a !== void 0 ? _a : null;
        setTemporaryToken(Object.assign(Object.assign({}, temporaryToken), { property: matchedProperty, operator }));
    };
    const operator = temporaryToken.operator;
    const onChangeOperator = (newOperator) => {
        setTemporaryToken(Object.assign(Object.assign({}, temporaryToken), { operator: newOperator }));
    };
    const value = temporaryToken.value;
    const onChangeValue = (newValue) => {
        setTemporaryToken(Object.assign(Object.assign({}, temporaryToken), { value: newValue }));
    };
    return (React.createElement(InternalPopover, { ref: popoverRef, className: styles['token-label'], triggerType: "text", header: i18nStrings.editTokenHeader, size: "large", position: "right", dismissAriaLabel: i18nStrings.dismissAriaLabel, __onOpen: () => setTemporaryToken(token), renderWithPortal: expandToViewport, content: React.createElement("div", { className: styles['token-editor'] },
            React.createElement("div", { className: styles['token-editor-form'] },
                React.createElement(InternalFormField, { label: i18nStrings.propertyText, className: styles['token-editor-field-property'] },
                    React.createElement(PropertyInput, { property: property, onChangePropertyKey: onChangePropertyKey, asyncProps: asyncProperties ? asyncProps : null, filteringProperties: filteringProperties, onLoadItems: onLoadItems, customGroupsText: customGroupsText, i18nStrings: i18nStrings, freeTextFiltering: freeTextFiltering })),
                React.createElement(InternalFormField, { label: i18nStrings.operatorText, className: styles['token-editor-field-operator'] },
                    React.createElement(OperatorInput, { property: property, operator: operator, onChangeOperator: onChangeOperator, i18nStrings: i18nStrings, freeTextFiltering: freeTextFiltering })),
                React.createElement(InternalFormField, { label: i18nStrings.valueText, className: styles['token-editor-field-value'] },
                    React.createElement(ValueInput, { property: property, operator: operator, value: value, onChangeValue: onChangeValue, asyncProps: asyncProps, filteringOptions: filteringOptions, onLoadItems: onLoadItems, i18nStrings: i18nStrings }))),
            React.createElement("div", { className: styles['token-editor-actions'] },
                React.createElement(InternalButton, { formAction: "none", variant: "link", className: styles['token-editor-cancel'], onClick: closePopover }, i18nStrings.cancelActionText),
                React.createElement(InternalButton, { className: styles['token-editor-submit'], formAction: "none", onClick: () => {
                        setToken(matchTokenValue(temporaryToken, filteringOptions));
                        closePopover();
                    } }, i18nStrings.applyActionText))) }, triggerComponent));
}
//# sourceMappingURL=token-editor.js.map