// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
import { useState, useEffect, useCallback } from 'react';
import { useStableCallback } from '../internal/stable-callback';
import { isDevelopment } from '../internal/is-development';
import { warnOnce } from '../internal/logging';
/**
 * This hook allows you to make a component that can be used both in controlled
 * mode and uncontrolled mode. Pass in your component's props, and then implement
 * your component as if it was only controlled.
 *
 * A component determines its mode (either controlled or uncontrolled) on the
 * first render and keeps it for its lifetime. The mode cannot be switched later.
 *
 * @example
 * Using useControllableState in a custom checkbox component
 * ```
 * const [checked, setChecked] = useControllable(
 *   props.checked,
 *   props.onChange,
 *   props.defaultEnabled ?? false,
 *   {
 *     componentName: 'MyCheckboxComponent',
 *     propertyName: 'checked',
 *     changeHandler: 'onChange'
 *   }
 * );
 *
 * return (
 *   <input
 *     type="checkbox"
 *     checked={checked}
 *     onChange={event => setChecked(event.target.checked)}
 *   />
 * );
 * ```
 *
 * @param controlledValue The value to use for controlled mode
 * @param changeHandler The update handler for controlled mode
 * @param defaultValue The initial value for uncontrolled mode
 * @param propertyDescriptions Property names used when emitting warnings
 * @param fireEvent Callback executed when controllable value changes
 * @returns A tuple of value and value setter
 */
export default function useControllable(controlledValue, changeHandler, defaultValue, propertyDescriptions, fireEvent) {
    if (fireEvent === void 0) { fireEvent = function (value, handler) { return handler(value); }; }
    var componentName = propertyDescriptions.componentName, changeHandlerName = propertyDescriptions.changeHandlerName, propertyName = propertyDescriptions.propertyName;
    // The decision whether a component is controlled or uncontrolled is made on
    // its first render and cannot be changed afterwards.
    var isControlled = useState(controlledValue !== undefined)[0];
    // Most build tools will just strip this block from production builds, so we can
    // skip the conditional hook lint error.
    if (isDevelopment) {
        // Print a warning if a controlled property was passed in without a change handler.
        // This may fire every render if the change handler isn't memoized, but warnOnce
        // will dedupe the error messages.
        // eslint-disable-next-line react-hooks/rules-of-hooks
        useEffect(function () {
            if (isControlled && changeHandler === undefined) {
                warnOnce(componentName, "You provided a `".concat(propertyName, "` prop without an `").concat(changeHandlerName, "` handler. This will render a non-interactive component."));
            }
        }, [changeHandler, isControlled, componentName, changeHandlerName, propertyName]);
        // Print a warning if the component switches between controlled and uncontrolled mode.
        var isControlledValueProvided_1 = controlledValue !== undefined;
        // eslint-disable-next-line react-hooks/rules-of-hooks
        useEffect(function () {
            if (isControlled !== isControlledValueProvided_1) {
                var initialMode = isControlled ? 'controlled' : 'uncontrolled';
                var modeNow = isControlledValueProvided_1 ? 'controlled' : 'uncontrolled';
                warnOnce(componentName, "A component tried to change ".concat(initialMode, " '").concat(propertyName, "' property to be ").concat(modeNow, ". ") +
                    "This is not supported. Properties should not switch from ".concat(initialMode, " to ").concat(modeNow, " (or vice versa). ") +
                    "Decide between using a controlled or uncontrolled mode for the lifetime of the component. " +
                    "More info: https://fb.me/react-controlled-components");
            }
        }, [isControlled, isControlledValueProvided_1, propertyName, componentName]);
    }
    // This is the value that is used if the component is uncontrolled.
    var _a = useState(defaultValue), valueState = _a[0], setValue = _a[1];
    var _b = useState(false), isUncontrolledValueSet = _b[0], setIsUncontrolledValueSet = _b[1];
    var stableFireEvent = useStableCallback(function (value, handler) { return fireEvent(value, handler); });
    var setControlledValue = useCallback(function (value) {
        if (changeHandler) {
            stableFireEvent(value, changeHandler);
        }
    }, [changeHandler, stableFireEvent]);
    // We allow changes to the defaultValue prop to be reflected until the component
    // starts controlling it internally.
    var currentUncontrolledValue = isUncontrolledValueSet ? valueState : defaultValue;
    var setUncontrolledValue = useCallback(function (newValue) {
        setValue(newValue);
        setIsUncontrolledValueSet(true);
    }, []);
    return isControlled ? [controlledValue, setControlledValue] : [currentUncontrolledValue, setUncontrolledValue];
}
