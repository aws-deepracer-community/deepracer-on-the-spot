// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
import { useEffect, useState } from 'react';
import { findUpUntil } from '../../dom';
import { createSingletonHandler } from '../singleton-handler';
import { useStableCallback } from '../stable-callback';
import { isDevelopment } from '../is-development';
import { warnOnce } from '../logging';
var awsuiVisualRefreshFlag = Symbol["for"]('awsui-visual-refresh-flag');
export function isMotionDisabled(element) {
    var _a, _b;
    return (!!findUpUntil(element, function (node) { return node.classList.contains('awsui-motion-disabled'); }) ||
        ((_b = (_a = window.matchMedia) === null || _a === void 0 ? void 0 : _a.call(window, '(prefers-reduced-motion: reduce)').matches) !== null && _b !== void 0 ? _b : false));
}
// Note that this hook doesn't take into consideration @media print (unlike the dark mode CSS),
// due to challenges with cross-browser implementations of media/print state change listeners.
// This means that components using this hook will render in dark mode even when printing.
export function useCurrentMode(elementRef) {
    var _a = useState('light'), value = _a[0], setValue = _a[1];
    useMutationObserver(elementRef, function (node) {
        var darkModeParent = findUpUntil(node, function (node) { return node.classList.contains('awsui-polaris-dark-mode') || node.classList.contains('awsui-dark-mode'); });
        setValue(darkModeParent ? 'dark' : 'light');
    });
    return value;
}
export function useDensityMode(elementRef) {
    var _a = useState('comfortable'), value = _a[0], setValue = _a[1];
    useMutationObserver(elementRef, function (node) {
        var compactModeParent = findUpUntil(node, function (node) { return node.classList.contains('awsui-polaris-compact-mode') || node.classList.contains('awsui-compact-mode'); });
        setValue(compactModeParent ? 'compact' : 'comfortable');
    });
    return value;
}
export function useReducedMotion(elementRef) {
    var _a = useState(false), value = _a[0], setValue = _a[1];
    useMutationObserver(elementRef, function (node) {
        setValue(isMotionDisabled(node));
    });
    return value;
}
var useMutationSingleton = createSingletonHandler(function (handler) {
    var observer = new MutationObserver(function () { return handler(); });
    observer.observe(document.body, { attributes: true, subtree: true });
    return function () { return observer.disconnect(); };
});
function useMutationObserver(elementRef, onChange) {
    var handler = useStableCallback(function () {
        if (elementRef.current) {
            onChange(elementRef.current);
        }
    });
    useMutationSingleton(handler);
    useEffect(function () {
        handler();
    }, [handler]);
}
// We expect VR is to be set only once and before the application is rendered.
var visualRefreshState = undefined;
// for testing
export function clearVisualRefreshState() {
    visualRefreshState = undefined;
}
function detectVisualRefresh() {
    return typeof document !== 'undefined' && !!document.querySelector('.awsui-visual-refresh');
}
export function useRuntimeVisualRefresh() {
    var _a;
    if (visualRefreshState === undefined) {
        visualRefreshState = detectVisualRefresh();
        if (!visualRefreshState && typeof window !== 'undefined' && ((_a = window[awsuiVisualRefreshFlag]) === null || _a === void 0 ? void 0 : _a.call(window))) {
            document.body.classList.add('awsui-visual-refresh');
            visualRefreshState = true;
        }
    }
    if (isDevelopment) {
        var newVisualRefreshState = detectVisualRefresh();
        if (newVisualRefreshState !== visualRefreshState) {
            warnOnce('Visual Refresh', 'Dynamic visual refresh change detected. This is not supported. ' +
                'Make sure `awsui-visual-refresh` is attached to the `<body>` element before initial React render');
        }
    }
    return visualRefreshState;
}
