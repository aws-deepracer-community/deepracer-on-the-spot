import { compareDates, compareTimestamps } from '../date-utils/compare-dates.js';
var filterUsingOperator = function (itemValue, tokenValue, _a) {
    var operator = _a.operator, match = _a.match;
    if (match === 'date' || match === 'datetime') {
        var comparator = match === 'date' ? compareDates : compareTimestamps;
        var comparisonResult = comparator(itemValue, tokenValue);
        switch (operator) {
            case '<':
                return comparisonResult < 0;
            case '<=':
                return comparisonResult <= 0;
            case '>':
                return comparisonResult > 0;
            case '>=':
                return comparisonResult >= 0;
            case '=':
                return comparisonResult === 0;
            case '!=':
                return comparisonResult !== 0;
            default:
                return false;
        }
    }
    else if (typeof match === 'function') {
        return match(itemValue, tokenValue);
    }
    else if (match) {
        throw new Error('Unsupported `operator.match` type given.');
    }
    switch (operator) {
        case '<':
            return itemValue < tokenValue;
        case '<=':
            return itemValue <= tokenValue;
        case '>':
            return itemValue > tokenValue;
        case '>=':
            return itemValue >= tokenValue;
        case '=':
            // eslint-disable-next-line eqeqeq
            return itemValue == tokenValue;
        case '!=':
            // eslint-disable-next-line eqeqeq
            return itemValue != tokenValue;
        case ':':
            return (itemValue + '').toLowerCase().indexOf((tokenValue + '').toLowerCase()) > -1;
        case '!:':
            return (itemValue + '').toLowerCase().indexOf((tokenValue + '').toLowerCase()) === -1;
        case '^':
            return (itemValue + '').toLowerCase().startsWith((tokenValue + '').toLowerCase());
        // The unsupported operators result in an exception being thrown.
        // The exception can be avoided if using the match function.
        default:
            throw new Error('Unsupported operator given.');
    }
};
function freeTextFilter(value, item, operator, filteringPropertiesMap) {
    var matches = Object.keys(filteringPropertiesMap).some(function (propertyKey) {
        var operators = filteringPropertiesMap[propertyKey].operators;
        return (!!operators[operator] && filterUsingOperator(item[propertyKey], value, { operator: ':' }));
    });
    return operator === ':' ? matches : !matches;
}
function filterByToken(token, item, filteringPropertiesMap) {
    if (token.propertyKey) {
        // token refers to a unknown property or uses an unsupported operator
        if (!(token.propertyKey in filteringPropertiesMap) ||
            !(token.operator in filteringPropertiesMap[token.propertyKey].operators)) {
            return false;
        }
        var operator = filteringPropertiesMap[token.propertyKey].operators[token.operator];
        var itemValue = (operator === null || operator === void 0 ? void 0 : operator.match)
            ? item[token.propertyKey]
            : fixupFalsyValues(item[token.propertyKey]);
        return filterUsingOperator(itemValue, token.value, operator !== null && operator !== void 0 ? operator : { operator: token.operator });
    }
    return freeTextFilter(token.value, item, token.operator, filteringPropertiesMap);
}
function defaultFilteringFunction(filteringPropertiesMap) {
    return function (item, _a) {
        var tokens = _a.tokens, operation = _a.operation;
        var result = operation === 'and' ? true : !tokens.length;
        for (var _i = 0, tokens_1 = tokens; _i < tokens_1.length; _i++) {
            var token = tokens_1[_i];
            result =
                operation === 'and'
                    ? result && filterByToken(token, item, filteringPropertiesMap)
                    : result || filterByToken(token, item, filteringPropertiesMap);
        }
        return result;
    };
}
export function createPropertyFilterPredicate(propertyFiltering, query) {
    if (query === void 0) { query = { tokens: [], operation: 'and' }; }
    if (!propertyFiltering) {
        return null;
    }
    var filteringPropertiesMap = propertyFiltering.filteringProperties.reduce(function (acc, _a) {
        var _b;
        var key = _a.key, operators = _a.operators, defaultOperator = _a.defaultOperator;
        var operatorMap = (_b = {}, _b[defaultOperator !== null && defaultOperator !== void 0 ? defaultOperator : '='] = { operator: defaultOperator !== null && defaultOperator !== void 0 ? defaultOperator : '=' }, _b);
        operators === null || operators === void 0 ? void 0 : operators.forEach(function (op) {
            if (typeof op === 'string') {
                operatorMap[op] = { operator: op };
            }
            else {
                operatorMap[op.operator] = { operator: op.operator, match: op.match };
            }
        });
        acc[key] = {
            operators: operatorMap,
        };
        return acc;
    }, {});
    var filteringFunction = propertyFiltering.filteringFunction || defaultFilteringFunction(filteringPropertiesMap);
    return function (item) { return filteringFunction(item, query); };
}
export var fixupFalsyValues = function (value) {
    if (typeof value === 'boolean') {
        return value + '';
    }
    if (value || value === 0) {
        return value;
    }
    return '';
};
// Keeping this function as there are customers depending on it.
export function propertyFilter(items, query, propertyFiltering) {
    var predicate = createPropertyFilterPredicate(propertyFiltering, query);
    return predicate ? items.filter(predicate) : items;
}
